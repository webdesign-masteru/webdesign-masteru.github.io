<!DOCTYPE html>
<html lang="ru">

<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="canonical" href="https://webdesign-masteru.github.io/blog/cms/568.html">
  <meta name="generator" content="Jekyll v">

  <title>Руководство по созданию тем на WordPress и StyleKit's с использованием Layers Framework</title>
  <meta name="description" content="Руководство по созданию чистых, WordPress совместимых дочерних тем и StyleKit's с использованием фреймворка Layers.">

  <link rel="icon" href="https://webdesign-masteru.github.io/favicon.ico?v=16" type="image/x-icon">
  <meta property="og:image" content="../../public/images/thumbs/cms/layer-rukovodstvo/layer-rukovodstvo-cover.jpg">

  <link rel="stylesheet" href="../../styles/index.css?v=16">
  
  <script src="../../scripts/dist/main.js?v=16" defer></script>
  
  <script>/* no flicker */document.documentElement.classList.add(localStorage.getItem('mode') === 'auto' ? (matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : localStorage.getItem('mode'))</script>

</head>

<body>

  <header class="main-head">

    <div class="container-fluid">

      <div class="row">

        <div class="col-md-6">
          <div class="mobile-pannel d-xl-none d-lg-none d-md-none">
            <div class="toggler"><button title="Переключить тему"></button></div>
            <div class="toggle-mnu"><span></span></div>
          </div>
        
          <a href="../../index.html" class="logo"><img src="../../assets/images/logo-site.svg" alt="WebDesign Master"></a>
        
        </div>

        <div class="col-md-6 d-none d-md-block d-lg-block d-xl-block">
          <div class="toggler"><button title="Переключить тему"></button></div>
                    <div class="social">
            <a title="ВКонтакте" href="https://vk.com/jediweb" target="_blank"><i class="fa fa-vk"></i></a>
            <a title="Телеграм" href="https://t.me/jediweb" target="_blank"><i class="fa custom-tg"></i></a>
            <a title="YouTube" href="https://youtube.com/@wdm" target="_blank"><i class="fa fa-youtube-play"></i></a>
            <a title="GitHub" href="https://github.com/webdesign-masteru" target="_blank"><i class="fa fa-github"></i></a>
            <a title="Дзен" href="https://dzen.ru/jediweb" target="_blank"><i class="fa custom-dzen"></i></a>
          </div>

          <div class="courses-link">
            <a href="../../courses/index.html"><i class="fa fa-diamond"></i>Курсы</a>
          </div>
        </div>

      </div>

      <div class="mobile-menu"></div>

    </div>

  </header>


  <div class="content">
    <div class="container-fluid">

      <div class="row">

        <div class="col-md-8">

          <article class="list-item single-page">
  <div class="item-link">

    
    <div class="item-img-wrap post-img">
      <img class="img-responsive" src="../../public/images/thumbs/cms/layer-rukovodstvo/layer-rukovodstvo.jpg" alt="Руководство по созданию тем на WordPress и StyleKit's с использованием Layers Framework">
    </div>
    

    <div class="item-content">

    <div class="td">
        <a href="../../blog/cms/index.html" class="item-icon hidden-xs" title="Категория: CMS/Framework"><i class="fa fa-wordpress"></i></a>
      </div>
      <div class="td article-title"><h1>Руководство по созданию тем на WordPress и StyleKit's с использованием Layers Framework</h1></div>
    

      <div class="article-content">

        <h4>Дополнительные материалы:</h4>

<ul>
  <li><a href="https://archive.org/download/layers-style-kit-demo/layers-style-kit-demo.zip">Архив с демонстрационным StyleKit</a></li>
  <li><a href="https://archive.org/download/layers-child-demo/Layers-Child-Demo.zip">Архив с демонстрационной темой</a></li>
  <li><a href="https://themeforest.net/attributes/framework/layers%20wp" target="_blank">Демо сайтов, созданных с использованием WordPress Layers</a></li>
  <li>Скачать <strong>WordPress</strong>: <a href="https://ru.wordpress.org/" target="_blank">https://ru.wordpress.org/</a></li>
  <li>Скачать <strong>Layers</strong>: <a href="https://archive.org/download/layerswp-2.0.10/layerswp-2.0.10.zip">Скачать</a></li>
</ul>

<p>Руководство по созданию чистых, WordPress совместимых <strong>дочерних тем</strong> и <strong>StyleKit</strong>'s с использованием фреймворка Layers.</p>

<h3>Что такое дочерняя тема?</h3>

<p>Дочерняя тема - это такая-же тема для WordPress, которая позволяет наследовать функционал родительской темы, интерфейс, структуру и логику. В случае разработки дочерней темы с использованием Layers, родительской темой выступает <strong>LayersWP</strong> Theme Framework.</p>

<p>Причины, по которым стоит использовать дочернюю тему:</p>

<ul>
  <li>Возможность безболезненно обновлять систему, обусловленная строгими критериям разработки тем на WordPress.</li>
  <li>Дочерние темы позволяют значительно ускорить процесс разработки.</li>
  <li>Дочерняя тема - это по сути автономный набор изменений, который легко разрабатывать и поддерживать.</li>
  <li>Кастомизация дочерней темы может потребовать только 100 строк кода, которыми легко управлять в одном месте, в то время, как родительская тема содержит тысячи базовых строк кода, которые мы кастомизируем посредством дочерней темы.</li>
  <li>Соответственно, на плечи разработчика ложится работа по поддержке всего 100 строк кода, а не всего фреймворка.</li>
  <li>Используя дочернюю тему, вы лучше узнаете правильную разработку на WordPress.</li>
</ul>

<h3>Когда стоит разрабатывать дочернюю тему</h3>

<p>Разделение тем и плагинов WordPress с некоторых пор стало достаточно размытым, так как и темы и плагины могут обеспечивать дополнительный функционал сайтам на WordPress.</p>

<p>Дочернюю тему стоит разрабатывать, если:</p>

<ul>
  <li>вы хотите изменять стили темы без использования инструмента WordPress Customizer и других плагинов.</li>
  <li>Вы хотите немного кастомизировать стили определенного блока, который уже готов к работе.</li>
  <li>Вы хотите добавлять пользовательские шаблоны в тему.</li>
</ul>

<p>Когда необходимо разрабатывать новое расширение:</p>

<ul>
  <li>Когда вы хотите добавить кастомные типы постов.</li>
  <li>Когда вы хотите добавить новый виджет в LayersWP.</li>
</ul>

<p>Если вы просто хотите создать легкий шаблон и передать его заказчику - вы можете сделать это наиболее простым способом - создать <strong>StyleKit</strong> для LayersWP, без расширения функционала фреймворка. Это лучший вариант для дизайнеров.</p>

<h3>Темы VS Расширения VS StyleKit</h3>

<blockquote>
<strong>StyleKit:</strong> коллекция прессетов, полученных от настроек LayersWP из админки. СтайлКиты включают настройку виджетов, опции, цвета, шрифты и иконки, которые вы использовали при настройке страницы в админке. <br>
<strong>Дочерняя тема:</strong> используется, когда возможностей StyleKit'а не достаточно для создания полноценного сайта по макету дизайнера. Как правило, дочерняя тема включает дополнительные стили, дополнительные скрипты и функции, а также дополнительные настройки и фильтры. <br>
<strong>Расширение:</strong> используется для введения полностью нового функционала в LayersWP, в том числе пользовательских типов постов и их шаблонов. <br>
</blockquote>

<h3>Руководство по созданию StyleKit</h3>

<p>Видео урок по созданию StyleKit на реальном примере.</p>

<div class="likely-scroll">
  <div class="likely">
    <button class="vkontakte">Поделиться</button>
    <button class="telegram">Отправить</button>
    <button class="pinterest" data-media="https://webdesign-masteru.github.io/public/images/thumbs/cms/layer-rukovodstvo/layer-rukovodstvo-cover.jpg">Запинить</button>
    <button class="odnoklassniki">Класснуть</button>
  </div>
</div>


<div class="video-wrap">
  <div class="table">
    <div class="tr">
      <div class="td">
        <div class="videowrapper" title="Смотреть урок «Руководство по созданию тем на WordPress и StyleKit's с использованием Layers Framework» на YouTube">
          <img class="img-responsive" src="../../public/images/thumbs/cms/layer-rukovodstvo/layer-rukovodstvo-cover.jpg" alt="Руководство по созданию тем на WordPress и StyleKit's с использованием Layers Framework - Видеоурок">
        </div>
        <a href="https://youtu.be/A6NyYxqcfFg" class="button button-youtube" target="_blank"><i class="fa fa-youtube-play"></i>Смотреть <span class="d-none d-lg-inline">урок </span>на YouTube</a>
      </div>
      <div class="td">
        <a href="../../courses/bundle/index.html" class="premium-banner">
          <img src="../../public/images/premium/bundle-b.jpg" alt="Все курсы канала WebDesign Master">
        </a>
      </div>
    </div>
  </div>
</div>


<p>Примеры StyleKit's: <a href="https://codecanyon.net/category/skins/layers-wp-style-kits" target="_blank">https://codecanyon.net/category/skins/layers-wp-style-kits</a></p>

<p>Это руководство подойдет более для новичков в веб-разработке и веб-дизайнеров, которые желают быстро создать красивый сайт на WordPress, но требует минимальных знаний CSS. Здесь определяются лучшие практики создания StyleKit's, предназначенных для продажи или передачи конечному заказчику (если разрабатываете сайты на заказ).</p>

<p>Мы рекомендуем установить чистую копию WordPress на ваш сервер. Кроме того, стоит учитывать, что проект, созданный с использованием LayersWP, должен иметь зеркальную копию на вашем сервере для разработки сайтов, так как клиент или покупатель StyleKit при установке на свою систему должен получить демо-данные из открытого источника (вашего dev сервера).</p>

<h4>Создание пресетов (StyleKit's) для Layers. Основные правила:</h4>

<ul>
  <li>Начинайте создавать свои пресеты для Layers с пустой страницы. При проектировании для широкой публики, должны быть использованы только нативные слои и виджеты Layers, так как дополнительный функционал при экспорте Кита клиенту не будет учитываться.</li>
  <li>Добавляйте кастомные стили только в специализированные поля для CSS - Design Bar.</li>
  <li>На странице редактора добавляйте понятные заказчику или конечному пользователю заголовки и псевдонимы. например, "Портфолио", "Наша команда", "Преимущества" и т.д.</li>
  <li>Экспортируйте каждую страницу в json (об этом далее).</li>
</ul>

<blockquote>Если ваш StyleKit предназначен для коммерческого распространения, вы должны установить демо на реальном сервере, прежде, чем экспортировать данные. Это гарантирует, что любые демонстрационные данные и изображения могут быть переданы на удаленный сервер и сэкономит время конечным пользователям на ручном импорте.</blockquote>

<h4>Кастомизация CSS LayersWP</h4>

<p>Каждый виджет имеет опцию "Продвинутое редактирование" на палитре для создания пользовательских классов. Эти классы будут добавлены к основному контейнеру виджета таким образом, что какие-либо свойства, применяемые к классу будут влиять только на этот контейнер (или любой другой виджет с аналогичным классом). Данное поле не является обязательным. Это позволяет применять стиль только к данному виджету или макету страницы и является единственным правильным способом для определения пользовательских классов, чтобы оформлять элементы в Layers, не касаясь HTML кода. Без него вы должны использовать гораздо более сложные селекторы для оформлени конкретных элементов и виджетов. Оформление в CSS id тоже не очень хорошая идея, так как эти идентификаторы уже могут быть использованы во внутренних стилях, якорях или JavaScrip.</p>

<p>Преимущество данного метода заключается в том, что пользовательские классы и стили, добавленные в "Продвинутое редактирование" сохраняются вместе с другими данными при экспорте данных StyleKit. Это делает импорт на сервере конечного пользователя более надежным.</p>

<h4>Как использовать панель "Продвинутое редактирование" для кастомизации CSS</h4>

<p>Каждый виджет имеет дополнительные опции на панели, которые содержат поле для CSS:</p>

<img src="../../public/images/blog/cms/layer-rukovodstvo/advanced-option.jpg" alt="Дополнительные опции">

<p>Опция CSS в главном меню Настройщика будет загружаться вместе со стилями темы. Если вы хотите что-то изменить глобально, не используйте это поле в виджетах. Для этих целей используйте более длинные цепочки каскада для кастомизации конкретных страниц или виджетов.</p>

<h4>Кастомные классы</h4>

<p>Пользовательские классы и стили, добавленные на панели "Продвинутое редактирование" сохраняются вместе с другими данными, при экспорте и импорте файла. В отличие от этого, пользовательский CSS, добавленный в основной области, применяется ко всему сайту.</p>

<p>Пользовательский класс автоматически добавляется к тегу &lt;section&gt; - HTML обертке секции.</p>
<p>Основные классы необходимо писать в поле основных стилей сайта на панели слева:</p>

<img src="../../public/images/blog/cms/layer-rukovodstvo/css-setting.jpg" alt="Основные CSS стили">

<p>Для того, чтобы добавить класс, нажмите кнопку "Продвинутое редактирование" на палитре, а затем введите имя класса в поле пользовательских классов без точки. Имена классов должны быть как можно короче, но уникальными.</p>

<p>Поменяем бэкграунд кнопки:</p>

<img src="../../public/images/blog/cms/layer-rukovodstvo/advanced-example1.jpg" alt="Кастомные классы CSS в Layers">

<p>Отсюда мы видим, какие манипуляции можно производить с кастомными классами:</p>

<ul>
  <li>Чтобы повлиять только на конкретный виджет - пользовательские стили размещаются в области пользовательских стилей виджета.</li>
  <li>Для того, чтобы повлиять глобально на этот виджет, стили размещаются в разделе "Пользовательский CSS", на панеле Кастомизатора. Это вам пригодитс в том случае, если вы хотите использовать один и тот-же стиль более одного разана нескольких страницах Layers, но не на всех виджетах, где есть кнопки.</li>
  <li>Для того, чтобы использовать стили несколько раз на одной странице - пользовательские стили размещаются вверху, на "Дополнительной панели" и только один класс может быть добавлен в эту область.</li>
</ul>

<h4>Класс для одного виджета</h4>

<p>Если вы хотите повлиять стилями только на один виджет, убедитесь, что имя класса виджета выбрано абсолютно уникальным и не используется повторно в другом месте на странице. Наиболее правильный способ обеспечить это - добавить семантический префикс, который поможет определить цель данного виджета. Например, app-slider или homepage-slider.</p>

<p>Ниже вы найдете простой пример, который показывает, как используется инспектор браузера, чтобы посмотреть существующие классы и существующие стили для заголовка. Затем мы добавили некоторые пользовательские стили, которые сочетает еаш пользовательский клас с классом в заголовке. Увеличим размер шрифта заголовка.</p>

<img src="../../public/images/blog/cms/layer-rukovodstvo/advanced-example2.jpg" alt="Пользовательские стили виджета Layers">

<p>Конечно, вариант "Продвинутое редактирование" требует немного знаний CSS, так как мы должны понимать, что такое класс, подкласс и так далее по каскаду. Это простой способ научиться CSS на готовой верстке всем тем, кто хочет разрабатывать веб-сайты.</p>

<h4>Глобальные классы с кастомными классами</h4>

<p>Пользовательские стили не обязательно могут быть добавленны именно в "Продвинутое редактирование". Если вы планируете использовать стиль в более, чем одном месте, например, для создания кнопки на основе изображения, которую вы хотите использовать на нескольких страницах, вы можете создать один пользовательский стиль со специальным именем класса и добавить его в основную область CSS.</p>

<p>В данном примере, мы комбинируем кастомный класс с именем app-button с классом большой кнопки btn-large:</p>

<img src="../../public/images/blog/cms/layer-rukovodstvo/btn-large-big.jpg" alt="btn-large button">

<p>Наша кастомная кнопка добавляется на CSS панель в основную область Кастомайзера - слева. Если вы хотите использовать этот код на другом сайте, загрузите кнопку на ваш dev сервер или преобразуйте его в текс base64.</p>

<pre class="language-css"><code>.app-button .button {
  background: url(http://localhost/layers/default/wp-content/uploads/appstore.png) no-repeat;
  text-indent: -9999px; 
  display: block; 
  height: 59px; 
  width: 190px; 
  transition: ease all .3s; 
  border-radius: 8px;
}
</code></pre>

<img src="../../public/images/blog/cms/layer-rukovodstvo/advanced-class-only.jpg" alt="Advanced Class">

<p>Если открыть еще один виджет, открыть панель "Продвинутое редактирование" и добавить такое-же имя пользовательского класса, то ко всем кнопкам с этим классом в виджете применятся соответствующие стили.</p>

<h4>Специфичные для страницы классы</h4>

<p>Таким-же образом можно применить стили для всех элементов страницы с таким классом. Если вы, например, хотите, чтобы все кнопки слайдера были белыми, как в нашем первом примере, но только на данной конкретной странице, вам нужно всего лишь добавить стиль в пользовательские CSS стили на панели сверху. Всем виджетам можно просто добавить соответствующих класс без точки.</p>

<h4>Padding и Margin</h4>

<p>Пространство между виджетами можно регулировать с помощью полей ввода Padding и Margin, каждое из которых соответствует верхней, правой, нижней и левой сторон виджета.</p>

<p>Margins применяются к наружним сторонам виджета. Paddings - к внутренним. Как в CSS. Чтобы уменьшить пространство между виджетами, устанавливается верхний отступ 20, а затем увеличивается или уменьшается это число на 5, пока вы не добъетесь требуемого результата.</p>

<img src="../../public/images/blog/cms/layer-rukovodstvo/padding.jpg" alt="Padding и Margin">

<h4>Анкоры виджета</h4>

<p>Это поле позволяет создавать ID виджета для ограницации плавной навигации по Landing Page.</p>

<h4>Глобальные кастомные стили</h4>

<p>Глобальные пользовательские стили используются для добавления глобального оформления и находятся на вкладке CSS в меню настройщика слева. При построении пользовательского CSS, имейте ввиду:</p>

<ul>
  <li>Никогда не копируйте все стили из инспектора или основных стилей - ваши стили должны содержать только изменения определенных свойств и новых дополнений к уже имеющемуся коду.</li>
  <li>Делайте ваш стили проще для понимания.</li>
  <li>Если ваш пользовательский CSS действительно велик и содержит много кода - то создавайте дочернюю тему WordPress Layers. В StyleKit стили должны быть как можно проще и их должно быть немного и они должны быть сосредоточены на основных изменениях, старайтесь все параметры настраивать в админке. Ваш StyleKit не должен содержать много CSS, хаки или жестко заданный размер шрифта - его можно настроить в админке виджета.</li>
</ul>

<p>Чтобы подготовить ваши кастомные стили для вашего StyleKit, просто скопируйте его в редактор и сохраните с именем <strong>css.txt</strong>.</p>

<p>Пример css.txt: <a href="https://github.com/Obox/layers-style-kit-demo/blob/master/css.txt" target="_blank">css.txt</a></p>

<h4>Экспорт контента</h4>

<p>Наличие содержимого StyleKit в XML является важным условием в обеспечении комфортного импорта данных клиентом. Перед экспортом проверьте следующее:</p>

<ul>
  <li>StyleKit не имеет тэгов Post -> Tags.</li>
  <li>Если ваш кит содержит демо посты, убедитесь, что любая из категорий, вами созданная соответствует вашему киту, в противном случае, создавайте только один с названием "Demo". Это сделает настройку и очистку содержания легче для конечного пользователя и снижает риск возникновения дубликатов.</li>
  <li>Прочие страницы Layers не должны использовать именования, такие, как "Главная", "Портфолио", "Магазин", или "Блог" в тайтле заголовка.</li>
  <li>Очистите корзину постов и страниц.</li>
  <li>Удалите все комментарии.</li>
  <li>Убедитесь, что все плагины отключены, чтобы избежать импорт лишних данных.</li>
</ul>

<blockquote>Если ваш StyleKit предназначен для коммерческого распространения, необходимо настроить демо на реальном сервере, прежде, чем экспортировать данные. Это гарантирует, что все изображения будут без проблем переданы на удаленный сервер.</blockquote>

<p>Экспортируйте весь контент инструментом "Экспорт" в WordPress. Назовите файл экспорта your_kit-content.xml где your_kit это название StyleKit'а. Например: kittn-content.xml</p>

<h4>Создайте файл Readme</h4>

<p>Ваш ридми должен включать общую информацию о вас, как об авторе, смотреть <a href="https://github.com/Obox/layers-style-kit-demo/blob/master/readme.txt" target="_blank">пример ридми</a> и некоторые основные инструкции по использованию. Вы можете скопировать readme.txt из примера и настроить под себя.</p>

<h4>Структура готового StyleKit</h4>

<ul>
  <li>
    <strong>folder</strong>
    <ul>
      <li><strong>images</strong></li>
      <li>css.txt</li>
      <li>layout-one.json</li>
      <li>layout-two.json</li>
      <li>kit_name-content.xml</li>
      <li>readme.txt</li>
    </ul>
  </li>
</ul>

<p>Что еще нужно не забыть сделать:</p>

<ul>
  <li>Протестируйте ваш кит на свежей WordPress.</li>
  <li>Упакуйте ваш кит в Zip архив и именуйте его следующим образом: <strong>kitname_layers-style-kit.zip</strong></li>
</ul>

<p>Скачать пример StyleKit: <a href="https://archive.org/download/layers-style-kit-demo/layers-style-kit-demo.zip">Скачать</a></p>

<h3>Руководство по созданию дочерней темы</h3>

<p>Создать дочернюю тему для WordPress снуля довольно просто. В этом разделе мы проведем вас через все этапы создания дочерней темы, которые вы сможете повторить на своей собственной дочерней теме.</p>

<p>Что вам понадобится:</p>

<ul>
  <li>Редактор кода, например, Sublime Text.</li>
  <li>Редактор изображений, для создания и редактирования .png файлов, например. Adobe Photoshop.</li>
</ul>

<h4>Создание директорий</h4>

<ol>
  <li>
    Создайте папку в нижнем регистре в каталоге с темами. Назовите ее layers-child.
    <img src="../../public/images/blog/cms/layer-rukovodstvo/child-theme-folder.png" alt="Child Folder">
  </li>
  <li>Создайте <strong>.css</strong> документ и сохраните его под именем <strong>style.css</strong></li>
  <li>Создайте новый <strong>.php</strong> файл и сохраните его под именем <strong>functions.php</strong></li>
  <li>В графическом редакторе создайте красивое превью темы в формате <strong>.png</strong> шириной 880px и высотой 660px. Сохраните его под именем <strong>screenshot.png</strong></li>
</ol>

<p>Теперь вы имеете скелет дочерней темы со следующей структурой:</p>

<ul>
  <li>
    <strong>layers-child</strong>
    <ul>
      <li>functions.php</li>
      <li>style.css</li>
      <li>screenshot.png</li>
    </ul>
  </li>
</ul>

<h4>Структурирование вашей темы</h4>

<p>Ваша дочерняя тема может работать используя всего один файл - <strong>style.css</strong>. Тем не менее, вы, вероятно, захотите создать что-то более сложное с дополнительными шаблонами, скриптами, функциями, стилями и изображениями. Мы рекомендуем использовать следующую структуру:</p>

<ul>
  <li>
    <strong>layers-child</strong>
    <ul>
      <li>assets</li>
      <li>css</li>
      <li>images</li>
      <li>
        js
        <ul>
          <li>theme.js</li>
        </ul>
      </li>
      <li>languages</li>
      <li>partials</li>
      <li>functions.php</li>
      <li>style.css</li>
    </ul>
  </li>
</ul>

<p>В тех случаях, когда вы планируете добавить дополнительные файлы, такие как изображения, сценарии или шаблон, то структура вашей дочерней темы должна максимально соответствовать структуре родительсткой темы (Layers).</p>

<p>Конечно, если вы начинаете делать темплейт с нуля, то ваши файлы не содержат ни какого кода и не делают ни чего полезного. Давайте исправим это путем создания файла <strong>style.css</strong>:</p>

<h4>style.css</h4>

<p>Style.css должен объявить имя папки родительского шаблона в заголовке правильно и наследовать функциональность и структуры родительской темы.</p>

<p>Ниже приведен пример, как должен выглядеть заголовок стилей в файле style.css:</p>

<pre class="language-css"><code>/*
 Theme Name: Layers Child
 Description: Layers Child Theme Test: https://www.oboxthemes.com
 Author: Obox Themes
 Template: layerswp
 Version: 1.0.0
 License: GPL 2.0
 License URI: https://www.gnu.org/licenses/gpl-2.0.html

**Color reference, for consistency**

  link color: #3D454C
  border color: #CCC
  light blue: #009DF3

**Table of contents**

  1. Header 
  2. Forms
  3. Invert 
  4. Buttons 
  5. Headings
  6. Sidebar
  7. Meta
  8. Footer 

/*---------------------------*/
/*- MAIN CSS ----------------*/
/*---------------------------*/

/*---------------------------*/
/*- 1 HEADER  -------*/
</code></pre>

<p><strong>Theme Name</strong>: должен соответствовать имени папки дочерней темы, заглавные буквы должны быть большими. Это поле используется для отображения названия вашей темы в WordPress.</p>
<p><strong>Description</strong>: Краткое описание шаблона, дополнительные детали</p>
<p><strong>Author</strong>: Автор Темы</p>
<p><strong>Template</strong>: наименование папки родительской темы. Это поле должно быть точным.</p>
<p><strong>Version</strong>: Версия шаблона. Начинается с 1.0.0</p>

<p>Далее идут поля для лицензии.</p>

<p>Ссылки на цвет не являются обязательными, но они помогают сохранить последовательность ваших цветовых оттенков, особенно, если вы любите проектировать в браузере.</p>

<p><strong>Table of Contents</strong>: Данный раздел помогает сохранить четкую организацию стилей CSS, если вы намерены представить свою тему для <strong>ThemeForest</strong>. Каждый элемент в таблице содержания соответствует комментариям в заголовке.</p>

<h4>Настройка functions.php</h4>

<p>Файл <strong>functions.php</strong> хранит большинство ваших пользовательских функций и хуков. По умолчанию он выглядит грустно и пусто. Данный файл должен начинаться с тега php:</p>

<pre class="language-php"><code>&lt;?php
// Custom Functions Go Below
</code></pre>

<p>Это все, что вам нужно сейчас, позже мы вернемся к этому файлу, чтобы добавить несколько функций.</p>

<h4>Установка и активация</h4>

<p>Тема готова к тому, чтобы ее установить и активировать. Вы можете сжать папку с дочерней темой в Zip архив и установить из админки WordPress, либо просто, закинув папку в категорию с темами в файловой системе.</p>

<p>Ниже мы подготовили стартовый шаблон, который уже содержит первоначальную структуру, справочные стили и функции, в том числе и то, что мы изучили ранее для того, чтобы проиллюстрировать, как должна работать дочерняя тема. Если вы опытный разработчик, мы рекомендуем использовать это скелет в своей работе.</p>

<a href="https://archive.org/download/layers-child-demo/Layers-Child-Demo.zip">Скачать стартовый шаблон</a>

<h4>Установка дочерней темы</h4>

<ol>
  <li>Убедитесь, что Layers установлен!</li>
  <li>Перейдите в раздел "Внешний вид -> Темы" и нажмите - добавить тему.</li>
  <li>Нажмите - загрузить тему.</li>
  <li>Нажмите "Обзор", выберите архив с дочерней темой и нажмите "Установить".</li>
  <li>Активируйте тему.</li>
</ol>

<h4>Стиллизация и шрифты</h4>

<p>Первре, что вы, вероятно, хотите настроить - это базовая стилизация вашей дочерней темы. В данном разделе приведены несколько советов о том, как быстро рестайлить основные компоненты темы и предотвратить ошибки в разработке.</p>

<h4>Настройка дефолтных цветов и шрифтов темы</h4>

<p>Большая часть Layers позволяет настраивать стили сайта в админке. Но если вы являетесь разработчиком темы, то вам необходимо установить дефолтные значания, до настройки темы пользователем в панели управления.</p>

<p>
  Для начала установите простой фильтр в <strong>functions.php</strong> с помощью хука <strong>layers_customizer_defaults</strong>
</p>

<pre class="language-php"><code>add_filter( 'layers_customizer_control_defaults', 'layers_child_customizer_defaults' );

function layers_child_customizer_defaults( $defaults ) {

  $defaults = array(
    'body-fonts' => 'Open Sans',
    'form-fonts' => 'Montserrat',
    'header-menu-layout' => 'header-logo-top',
    'header-background-color' => '',
    'site-accent-color' => '#f00',
    'footer-background-color' => '',
    'header-width' => 'layout-fullwidth',
    'header-sticky' => '1',
    'heading-fonts' => 'Montserrat',
    'footer-sidebar-count' => '0',
  );

  return $defaults;
}
</code></pre>

<p>В этом примере мы устанавливаем по умолчанию шрифты Заголовка макета, Тела и Форм, верхний и нижний колонтитулы, цвета и число по умолчанию нижнего колонтитула виджетов. Когда конечный пользователь активирует нашу дочернюю тему, данные параметры будут выставлены в админке с соответствующими значеними. Это значительно упрощает настройку макета клиентам и работать с ней становится проще.</p>

<h5>Давайте разберем функцию по полочкам</h5>

<p>В первой строке определяется уникальное имя пользовательской функции. Здесь для примера мы называем ее <strong>layers_child_customizer_defaults</strong>. Вы можете назвать ее по своему, например, <strong>layers_business_customizer_defaults</strong>? если ваша тема назыывается "Layers Business".</p>

<p>Начиная со строки 3 вы можете установить значение каждого параметра в массиве. После кажого элемента ставится запятая в конце строки.</p>

<pre class="language-php"><code>'option-name' => 'value',</code></pre>

<p>Для опции цвета в шестнадцатеричной системе вы можете поставить акцентный цвет или оставить пустое значение. Цвета, которые задаются пользователем в админке - переопределяют данные значения, как и все другие параметры.</p>

<p>В заключении, на строке 17 используйте <strong>add_filter</strong> для аргументов <strong>1defaults</strong> (layers_child_customizer_defaults), в оригинале (layers_customizer_control_defaults).</p>

<p>Смотрите, не так уж и плохо! В следующей главе мы более подробно рассмотрим хуки и фильтры для того, чтобы вы могли создавать свои пользовательские функции. Это необходимо дл добавления пользовательского HTMl или создания нового виджета в вашей теме.</p>

<h4>Стили Layers</h4>

<p>Теперь у вас есть настройки по умолчанию и вы можете перейти к более точной стилизации дочерней темы в <strong>style.css</strong>.</p>

<blockquote>Внимание! Не копируйте ценлые блоки стилей в вашу дочернюю тему из инспектора браузера.</blockquote>

<p>Layers разделяет все стили на несколько файлов для поддержания понятной структуры темы.</p>

<p><strong><a href="https://github.com/Obox/layerswp/blob/master/assets/css/framework.css" target="_blank">framework.css</a></strong> - содержит базовые стили. В большинстве случаев вы ни когда не должны изменять данные стили.</p>

<p><strong><a href="https://github.com/Obox/layerswp/blob/master/assets/css/components.css" target="_blank">components.css</a></strong> - содержит стили для виджетов и других компонентов Layers. Кастомайзер позволяет контролировать большую часть оформления здесь, но изменять их нужно с осторожностью.</p>

<p><strong><a href="https://github.com/Obox/layerswp/blob/master/assets/css/responsive.css" target="_blank">responsive.css</a></strong> - стили, отвечающие за адаптивность сайта.</p>

<p><strong><a href="https://github.com/Obox/layerswp/blob/master/assets/css/woocommerce.css" target="_blank">woocommerce.css</a></strong> - пользовательские стили Layers для магазина <strong>WooCommerce</strong>: оформление заказа, корзину.</p>

<p>Данные ссылки на GitHub могут быть использованы для справки, чтобы была возможность посмотреть оригинальный стиль в контексте зависимых и родительских селекторов. Можно также посмотреть стили и в инспекторе браузера, там вы также можете видеть, в каком файле и какой каскад содержит необходимые стили.</p>

<h4>Быстрый рестайлинг</h4>

<p>Для начала кастомизации стилей, откройте пустой <strong>style.css</strong> или работайте с образцом, который мы представили выше. Ни когда не копируйте оригинальные стили вашей дочерней темы, так как это ослабляет имунитет к свойствам родительского стиля в каскаде, а также загружает ненужные данные на страницу.</p>

<p>Лучше использовать тот-же селектор или удлиненный родителем для переопределения тех свойств, которые вы хотите изменить.</p>

<p>Ниже приведены некоторые советы о том, как быстро построить нужные CSS каскады с помощью инспектора браузера:</p>

<ul>
  <li>Смотрите стили сверху-вниз, так как cверху отображаются самые сильные селекторы.</li>
  <li>Проверяйте все изменения в инспекторе браузера.</li>
  <li>Скопированные доминирующие селекторы можно переопределить в вашем CSS.</li>
</ul>

<h4>Инспектирование элементов вашей дочерней темы</h4>

<p>Инспектор кода доступен практически в любом современном браузере, будь то Chrome, Firefox, Opera или Safari.</p>

<img src="../../public/images/blog/cms/layer-rukovodstvo/inspect-element.jpg" alt="Инспектирование элементов в браузере">

<p>Выберите интересующий элемент в окне просмотре HTML слева, пусть это будет &lt;header&gt;, он должен подсветиться в основном окне просмотра.</p>

<img src="../../public/images/blog/cms/layer-rukovodstvo/inspector1.jpg" alt="Инспектор Chrome">

<p>Все стили данного элемента можно просмотреть в окне CSS справа.</p>

<p>Селектор с наибольшим каскадом окажется выше других в окне просмотра CSS. Это означает, что стиль, примененный к заголовку будет влиять на все теги заголовков, в то время, как <strong>.header-site</strong> влияет только на элементы данного класса. Заголовок <strong>.wrapper-site</strong> будет влиять на все заголовки, специфичные для контейнера и класса <strong>.wrapper-site</strong>.</p>

<p>Вы можете взять сформированный инспектором каскад. Для специфичных секций указывается в начале каскада родителя, которого нет в сформированном инспектором каскаде.</p>

<blockquote>Важно! Избегайте использование !important. Если вы работаете с !important, значит вы неправильно определили каскад.</blockquote>

<h4>Проверка изменений</h4>

<p>Самый простой способ посмотреть изменения - это щелкнуть в свободном пространстве Кастомайзера. Также можно проверить изменения в инспекторе браузера.</p>

<img src="../../public/images/blog/cms/layer-rukovodstvo/click_stylesheet.png" alt="Проверка стилей">

<p>Все измененные свойства стилей немедленно должны отобразитьс в окне браузера на вашем сайте. Ок, но что делать, если вы все еще не определили правильный каскад?</p>

<h4>Селекторы, переопределения и каскад</h4>

<p>Использование инспектора браузера - самый быстрый способ узнать селектор элемента и определить родительский. Но бывает и так, что при попытке изменить какое-то свойство, результата вы не видите. В некоторых случаях помогает добавление родителя в начало каскада.</p>

<p>Некоторые стили задаются непосредственно элементам.</p>

<img src="../../public/images/blog/cms/layer-rukovodstvo/sitename.jpg" alt="Название сайта в инспекторе CSS">

<p>Если вы проверите тег &lt;h3&gt;, то заметите, что там цвет не задан. Даже если бы он был задан у тега H3, ссылка все равно была бы другого цвета, так как преимущество тега a в html сильнее, чем у родителей. В таком случае нужно указать цвет непосредственно. тегу A через каскад с родителем:</p>

<pre class="language-css"><code>.sitename a{color: #fff;}</code></pre>

<p>Вы также перед публикацией ссылок можете создавать новый каскад в инспекторе, редактировать нужным образом, а затем вставлять в свой CSS.</p>

<h4>Определение специфичных селекторов всей страницы</h4>

<p>Если вы хотите изменить стиль элемента на конкретной странице, вам нужно брать в каскад в качестве главного родитедя ID всей страницы, чтобы браузер понимал, что изменения должны коснуться только этой страницы.</p>

<p>Используя инспектор найдите тег &lt;body&gt; и посмотрите название класса:</p>

<img src="../../public/images/blog/cms/layer-rukovodstvo/bodyclass.png" alt="Класс тега body">

<p>В данном примере, селектор шаблона для этой страницы - "<strong>page-template-fullwidth-php</strong>". Можно использовать и класс <strong>.page</strong> для всех страниц, но в данном случае, мы хотим изменить стили на конкретно этой странице сайта.</p>

<h4>Подключение CSS в functions.php</h4>

<p>Стили Layers не обязательно загружать в какие-то другие файлы, кроме <strong>style.css</strong>, но удобнее использовать несколько тематических файлов, чтобы лучше организовать определенные части стиллизации. <strong>framework.css</strong> является основным файлом стилей, который управляет всем макетом и всегда загружается первым, а затем все стальные стили компонентов, стили адаптивности.</p>

<p>Для примера подключим необходимые стили компонентов родительского шаблона и какого-то плагина в functions.php:</p>

<pre class="language-php"><code>wp_dequeue_style('layers-components');

wp_enqueue_style(
  'layers-components',
  get_template_directory_uri() . '/assets/css/components.css',
  array('layers-framework')
); // Components

wp_dequeue_style('plugin-style-name');

wp_enqueue_style(
  'plugin-style-name',
  plugins_url() . '/plugin-name/css/main.css',
  array('layers-style')
); // Plugin
</code></pre>

<p>Теперь при загрузке страницы эти стили будут загружены перед стилями дочерней темы.</p>

<h4>Настраиваем правильные пути</h4>

<p>Есть несколько способов получения путей в WordPress, которые применяются для использования в теме и функциях. Давайте рассмотрим разницу между ними:</p>

<p><code>get_template_directory_uri()</code> - вернет URL <strong>родительской</strong> темы (http://localhost/wp-content/themes/layers).</p>

<p><code>get_stylesheet_directory_uri()</code> - вернет URL <strong>дочерней темы</strong> без конечного слеша (http://localhost/wp-content/themes/layers-child).</p>

<p><code>get_stylesheet_directory()</code> - вернет абсолютный путь сервера до дочерней темы без последнего слеша (/home/user/public_html/wp-content/themes/layers-child).</p>

<p><code>get_template_directory()</code> - вернейт абсолютный путь до родительской темы (/home/user/public_html/wp-content/themes/layers).</p>

<p><code>plugins_url()</code> - вернет абсолютный путь до плагинов без последнего слеша.</p>

<h4>Изображения, шрифты и изменение иконок</h4>

<p>Layers может не использовать иконки на основе изображений или спрайты во фронтенде темы и вы можете использовать шрифтовые иконки в шаблоне. Следующий пример показывает, как можно подключить FontAwesome в начале загрузки всех стилей:</p>

<pre class="language-php"><code>if( ! function_exists( 'layers_child_styles' ) ) {    

  function layers_child_styles() {

    wp_enqueue_style(
      'font-awesome',
      '//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css';
    ); // FontAwesome
  }
}
</code></pre>

<p>Когда вы включаете библиотеку FontAwesome в вашу дочернюю тему, вы должны установить относительный путь:</p>

<pre class="language-php"><code>wp_enqueue_style(
  'font-awesome',
  get_stylesheet_directory_uri.'/assets/fonts/fontawesome/fontawesome.css';
); // FontAwesome
</code></pre>

<h4>Google Fonts</h4>

<p>Нет необходимости добавлять шрифты Google в functions.php, как другие кастомные стили и стили темы. Вместо этого, можно установить шрифт в настройщик темы по умолчанию, как описано в начале статьи. Пример с настройками шрифта:</p>

<pre class="language-php"><code>function layers_child_customizer_font_defaults( $defaults ) {

  $defaults = array(
    'heading-fonts' => 'Merriweather',
    'body-fonts' => 'Lato',
    'form-fonts' => 'Lato',
  );
  return $defaults;

}

add_filter( 'layers_customizer_control_defaults', 'layers_child_customizer_font_defaults' );
</code></pre>

<p>Этот метод важен, посколько экономит куча времени на подключении шрифтов.</p>

<h4>Кастомные шрифты</h4>

<p>Пользователькие шрифты, которые отсутствуют в шрифтах Google могут быть добавлены в дочернюю тему с помощью @font-face в <strong>style.css</strong> или более правильным методом в functions.php</p>

<p>Для подключения шрифта, создадим отдельную таблицу стилей <strong>fonts.css</strong> и подключим в functions.php там, где подключаются стили:</p>

<pre class="language-php"><code>wp_enqueue_style(
  'custom-font',
  get_stylesheet_directory_uri.'/assets/css/fonts.css',
  array('layers-style')
);
</code></pre>

<h4>Включение в тему скриптов и PHP файлов</h4>

<h5>Подключение JavaScript</h5>

<p>
  Любой новый скрипт должен быть располопжен в дочерней теме в директории <strong>assets/js</strong>, затем подключен в functions.php посредством <strong>wp_enqueue_script</strong>
</p>

<pre class="language-php"><code>if( ! function_exists( 'layers_child_scripts' ) ) {

  function layers_child_scripts() {

    wp_enqueue_script(
      'layers-child' . '-custom',
      get_stylesheet_directory_uri() . '/assets/js/theme.js',
      array(
        'jquery', // make sure this only loads if jQuery has loaded
      )
    ); // Custom Child Theme jQuery  

  }

}

add_action('wp_enqueue_scripts', 'layers_child_scripts');
</code></pre>

<blockquote>Чтобы изменить сценарии Layers, такой, как сладер, например, не стоит копировать этот сценарий из родительской темы в дочернюю. Вместо этого используйте API и включите фрагменты jQuery сниппетов для управления какими лио аргументами, скрипт подключится к вашему theme.js файлу.</blockquote>

<h4>Подключение PHP файлов</h4>

<p>Если какой-то PHP функционал хранится в вашей дочерней теме, то вы можете подключить его в тему посредством <strong>require_once(1path)</strong>.</p>

<pre class="language-php"><code>require_once( get_stylesheet_directory() . '/assets/my_filters.php' );</code></pre>

<h4>Добавление кода с хуками Action</h4>

<p>Actions позволяют вставлять пользовательскую функцию или немного кода в определенное место основной программы. Вы можете создать пользовательское действие с помощью Wordpress <a href="https://developer.wordpress.org/reference/functions/add_action/" target="_blank">Action API</a> для удаления или добавления кода в любых программах. Это называется "Хукинг".</p>

<p>Layers предлагает работу с Action API для подключения ваших собственных пользовательских действий. Это позволяет вам настроит шаблоны с вашими функциями или HTML без необходимости копировать весь код дочернюю тему.</p>

<p>Например: Вы можете добавить свой код в футер сайта. Это может быть достигнуто путем написания новой функции, содержащей ваш пользовательский код, а затем подключить его к wp_footer, или вы можете использовать Layers Action API, для оптимального размещения таких действий, как "layers_before_footer_copyright", который будет выводить элемент чуть выше копирайта на сайте.</p>

<p>Пользовательские экшены отличаются от пользовательских фильтров тем, что пользовательские экшены позволяют добавить или удалить код из существующих экшенов, а пользовательские фильтры позволяют заменить конкретные данные (например, переменной или класса), найденные в рамках существующих экшенов.</p>

<h4>Изменение кода с помощью фильтров</h4>

<p>Фильтры позволяют изменить или удалить существующую функцию</p>

<p>Например, вы, возможно, захотите вставить еще один класс CSS в HTML элемента, или изменить хлебные крошки. Использование фильтров снижает необходимость копировать целые шаблоны или основные файлы Layers в вашу дочернюю тему и избавляет вас от необходимости постоянно проверять различные изменения после обновлений.</p>

<h4>Пользовательские шаблоны страниц</h4>

<p>Кастомные шаблоны страниц могут включать различные архивные макеты, улучшенную версию стандартных страниц Layers, которые содержат пользовательские виджеты или шаблоны, которые поддерживают специальные типы постов, а также, пользовательских макетов интернет-магазина WooCommerce.</p>

<h4>Добавление нового шаблона страницы</h4>

<p>В этом разделе мы рассмотрим добавление пользовательских шаблонов, отличных от стандартных Layers шаблонов.</p>

<p>Каждый новый шаблон страницы должен начинаться с заголовка, определяющего наименование темплейта.</p>

<pre class="language-php"><code>&lt;?php
/*
Template Name: My Custom Page
*/
get_header(); ?&gt;
</code></pre>

<p>Отсюда следует разметка, которая соответствует структуре стандартных шаблонов Layers:</p>

<pre class="language-php"><code>&lt;?php get_template_part( 'partials/header' , 'page-title' ); ?&gt;

&lt;section &lt;?php post_class( 'content-main archive clearfix' ); ?&gt;&gt;
  &lt;?php do_action('layers_before_page_loop'); ?&gt;
  &lt;div class="row"&gt;

  &lt;?php if( have_posts() ) : ?&gt;
    &lt;?php while( have_posts() ) : the_post(); ?&gt;

    &lt;article &lt;?php layers_center_column_class(); ?&gt;&gt;
      &lt;?php get_template_part( 'partials/content', 'single' ); ?&gt;
    &lt;/article&gt;

    &lt;?php endwhile; // while has_post(); ?&gt;
  &lt;?php endif; // if has_post() ?&gt;

  &lt;/div&gt;
  &lt;?php do_action('layers_after_page_loop'); ?&gt;
&lt;/section&gt;

&lt;?php get_footer(); ?&gt;
</code></pre>

<h5>Строка 1: Title</h5>

<p>Вы можете вызвать данную функцию, чтобы загрузить заголовок непосредственно с помощью Layers Framework, для того, чтобы состряпать секцию заголовка. Вот пример того, как мы настраиваем загаловок на кастомной странице результатов поиска по сайту:</p>

<pre class="language-php"><code>&lt;section class="title-container"&gt;
  &lt;div class="title"&gt;
    &lt;h2 class="heading"&gt;&lt;?php printf( __( 'Search Results for: %s', LAYERS_CHILD_THEME_SLUG ), get_search_query() ); ?&gt;&lt;/h2&gt;
  &lt;/div&gt;
&lt;/section&gt;
</code></pre>

<h5>Строка 3: &lt;section&gt;</h5>

<p>Каждый контейнер страницы завернут в секцию и должен содержать post_class(). В данной функции мы устанавливаем два минимальных необходимых классов: content-main и clearfix. Вы можете настроить это для того, чтобы вставить автоматически сгенерированный ID, если это одностраничный сайт. Вы также можете вставить свой собственный класс в post_class.</p>

<pre class="language-php"><code>&lt;section id="post-&lt;?php the_ID(); ?&gt;" &lt;?php post_class( 'content-main clearfix' ); ?&gt;&gt;</code></pre>

<p>или</p>

<pre class="language-php"><code>&lt;section &lt;?php post_class( 'content-main clearfix archive custom-class' ); ?&gt;&gt;</code></pre>

<h5>Стрки 4 и 18: Экшен хуки перед и после цикла</h5>

<p>Добавьте хук layers_before_page_loop, если вы хотите использовать для вывода своего собственного кода в этом шаблоне. Не забудьте сослаться на эти хуки при разработке документации перед продажей шаблона.</p>

<h5>Строка 5: &lt;row&gt;</h5>

<p>Строка row нужна для безопасности и стилизации, но пропущена быть не должна ни в коем случа.</p>

<h5>Строка 6: Цикл</h5>

<p>Каждый шаблон должен содержать цикл, если он предназначен для вывода содержимого или фида постов. Вы можете не использовать цикл, если ваш шаблон предназначен не для этого, а например, для вывода виджетов в определенных областях. Шаблоны страниц, включенные в Layers используют примерные циклы вывода. В нашем примере цикл является стандартным, без каких-либо модификаций, который выводит последние статьи. Для определения вывода в цикле вы должны использовать исключительно WP_Query.</p>

<h5>Строка 10: &lt;article&gt;</h5>

<strong>&lt;article&gt;</strong> является наиболее распространенным в кастомных шаблонах. Функция <strong>layers_center_column_class</strong> используется для автоматической установки классов с включенным span или определяетширину контента. Это позволяет динамически регулировать данный контейнер, в зависимости от настроек компоновки пользовательского сайдбара. Если вы не используете данный функционал в вашей теме, вы можете устанавливать классы вручную.

<p>Для получения полной ширины страницы:</p>

<pre class="language-php"><code>&lt;article &lt;?php layers_center_column_class(); ?&gt;&gt;
&lt;!-- заменяем на --&gt;
&lt;article class="column span-12"&gt;
</code></pre>

<h5>Строка 11: Фрагменты</h5>

<p>Наш пример кода использует <strong>uses get_template_part</strong>, можете посмотреть в папке родительской темы Layers /partials. Фрагменты разделяют ваш шаблон на отдельные файлы, которые могут быть повторно использованы в других шаблонах и помогают сохранить правильную организацию темы, сводя к минимуму дублирование кода.</p>

<p>Фрагменты нужно хранить в корне темы или в каталоге /partials дочерней темы. Всегда проверяйте путь до подключаемого файла.</p>

<pre class="language-php"><code>&lt;?php get_template_part( 'partials/content', 'single' ); ?&gt;</code></pre>

<h5>Строка 21: Footer</h5>

<p>Чтобы завершить шаблон, всключите футер.</p>

<pre class="language-php"><code>&lt;?php get_footer(); ?&gt;</code></pre>

<h5>Области виджетов</h5>

<p>Обычно структура виджета следующая: Title > Content > Footer. Если вы хотите создать шаблон страницы, который включал бы области виджета или боковые панели, вы можете включить их, используя любую из функций Layers Sidebar или зарегистрировать кастомный сайдбар и вывести его с помощью dynamic_sidebar().</p>

<p>Для начала нужно зарегистрировать область виджета или сайдбар в вашей дочерней теме, в файле functions.php. В следующем примере у нас есть собственный шаблон страницы, который выводит последние посты и сайдбар, используя Layerы Blog на главную страницу и включает пользовательскую область виджета для добавления виджетов до контента нашего темплейта.</p>

<pre class="language-php"><code>add_action( 'widgets_init' , 'layers_child_register_standard_sidebars' , 50 );

if (!function_exists('layers_child_register_standard_sidebars')) {
  function layers_child_register_standard_sidebars() { 
    register_sidebar( array(
      'id' => 'home-page-blog-top',
      'name' => __( 'Home Page Above Blog' , 'layers-child-slug' ),
      'description' => __( '' , 'layers-child-slug' ),
      'before_widget' => '',
      'after_widget' => '',
      )
    );
  }
}
</code></pre>

<p>Обратите внимание, что значения <strong>before_widget</strong> и <strong>after_widget</strong> пустые, так как каждый виджет будет на выходе иметь свою оболочку, используя &lt;section&gt;Элемент.</p>

<p>Значение ID является важным и используется в вызове сайдбара в вашей теме WordPress.</p>

<p>Теперь для нашего шаблона напишем:</p>

<pre class="language-php"><code>&lt;?php
/**
* Template Name: Home Blog
* The template for displaying post archives on the homepage
*
*/

get_header(); ?&gt;

&lt;?php do_action('before_layers_builder_widgets'); ?&gt;

&lt;?php if ( is_active_sidebar( 'home-page-blog-top' ) ) {
  dynamic_sidebar( 'home-page-blog-top' ); 
} ?&gt;

&lt;section &lt;?php post_class( 'content-main archive clearfix' ); ?&gt;&gt;

&lt;?php
/**
* Maybe show the left sidebar
*/
layers_maybe_get_sidebar( 'left-sidebar', 'column pull-left sidebar span-3' ); ?&gt;

&lt;?php 
// Make sure pagination works and only grab 3 posts: https://developer.wordpress.org/reference/classes/wp_query/#pagination-parameters
if ( get_query_var('paged') ) { $paged = get_query_var('paged'); }

elseif ( get_query_var('page') ) { $paged = get_query_var('page'); }
else { $paged = 1; }

$args = array(
  "post_type" =&gt; "post",
  "paged" =&gt; $paged,
  "posts_per_page" =&gt; 3
);

$wp_query = new WP_Query($args);
// Begin Loop
if( $wp_query-&gt;have_posts() ) : ?&gt;

&lt;article &lt;?php layers_center_column_class(); ?&gt;&gt;
</code></pre>

<p>Разберем шаблон.</p>

<h5>Строка 3: Заголовок темплейта</h5>

<p>Здесь мы определим на шаблон как Home Blog</p>

<h5>Строка 10: before_layers_builder_widgets hook</h5>

<p>Хук <strong>before_layers_builder_widgets</strong> ялется обязательным. В строке 11 мы включаем нашу пользватаельскую зону для виджета непосредственно, так как она не используется на других страницах, но мы также могли сделать это хукингом в functions.php с <strong>is_page_template</strong>, например:</p>

<pre class="language-php"><code>add_action('before_layers_builder _widgets', 'add_home_blog_widgets'); 

function add_home_blog_widgets(){

  if( is_page_template('home-blog.php') ) {
    dynamic_sidebar( 'home-page-blog-top' );
  }

}
</code></pre>

<h5>Строка 11: кастомная область для виджета</h5>

<p>Пользовательские области виджета можно включить, как и любой сайдбар и проверять активность условием is_active_sidebar.</p>

<pre class="language-php"><code>&lt;?php if ( is_active_sidebar( 'home-page-blog-top' ) ) {
  dynamic_sidebar( 'home-page-blog-top' ); 
} ?&gt;
</code></pre>

<h4>Переопределение дефолтных шаблонов</h4>

<p>Ояпть же, хукинг должен использоваться везде, где это возможно для изменения существующих шаблонов в Layers Framework. Есть случаи, когда просто можете изменить сам шаблон, который требует переопределения.</p>

<p>Все, что вам нужно сделать, чтобы переопределить шаблон, это скопировать его в каталог дочерней темы, используя ту же файловую структуру, как и у родительской темы Layers.</p>

<p>Есть некоторые моменты, которые вы не должны изменять в существующих шаблонах Layers и некоторые правила:</p>

<ul>
  <li>Не изменяйте заголовок типов. Layers активно работает с экспертами SEO, чтобы определить наиболее эффективный заголовок и структуру, а заголовки напрямую связаны со стилями типографики фреймворка.</li>
  <li>Не изменяйте существующие HTML элементы? взятые из Layers Framework, лучше их добавлять.</li>
  <li>Не удаляйте классы или функции по умолчанию, вызванные внутри враппера, иначе есть риск сломать функциональность фреймворка или перебить настройки. Лучше добавлять классы.</li>
  <li>Не используйте query_posts() для изменения дефолтного запроса.</li>
</ul>

<h4>Кастомные типы постов и таксономии</h4>

<h4>Кастомные мета поля</h4>

<p>Пользовательские мета поля просто формируются из полей, добавленных в редакторе поста, настройщик или в опции виджета. Значение этих полей можно извлекать различными способами.</p>

<blockquote>Если вы разрабатываете сайт для одного клиента, а не публичную тему или плагин, то вам легче будет работать с плагином <strong>Advanced Custom Fields</strong>.</blockquote>

<h4>Произвольные поля на странице редактирования</h4>

<p>Это не специальный способ добавления мета в редакторе из дочерней темы Layers - это традиционный способ WordPress. Тем не менее, вы можете воспользоваться фреймворком Layers для построения элементов для себя, расширяя Layers_Form_Elements через замечательную функцию <strong>input()</strong>.</p>

<p>Руководство по процедурному способу:</p>

<h5>Создайте файл</h5>

<p>Для начала создайте PHP документ под названием <strong>meta.php</strong> и сохраните его в вашей дочерней теме в папке <strong>/includes</strong>.  Начальная структура файла:</p>

<pre class="language-php"><code>&lt;?php
/**
* My Theme Custom Meta
* https://webdesign-masteru.github.io
**/

// Add The Meta Box

//Add The Callback
  //Build the form with Layers_Form_Elements

//Save The Meta
</code></pre>

<p>Далее мы будем создавать функционал в этом файле, в том числе и в главном файле функций.</p>

<p>В этом примере я покажу, как можно добавить фото и поле для url. Если у вас есть созданный тип постов, то вы можете применить это к другим типам записи довольно просто.</p>

<h5>Добавление метабокса</h5>

<pre class="language-php"><code>/**
* Add The Meta Box
**/
function layers_child_add_meta_box() {

  $screens = array('post');
  foreach ( $screens as $screen ) {
    add_meta_box(
      'layers_child_meta_sectionid',
      __( 'My Theme Options', 'layerswp' ),
      'layers_child_meta_box_callback',
      $screen,
        'normal',
        'high'
    );
  }
}
</code></pre>

<p><strong>Строка 3:</strong> - Настройка вашей функции. Наименование должно быть уникальным и заканчиваться на *_add_meta_box, чтобы избежать возможных конфликтов с другими темами или плагинами (т.е. не использовать ‘layers_child_’ как ваш префикс).</p>

<p>
  Например: <strong>yourtheme_postype_add_meta_box</strong>
</p>

<p><strong>Строка 6:</strong> - Переменная 1screen позволяет настроить массив типов постов, которые должны ассоциироваться с вашим метабоксом. По умолчанию, в Layers это просто "post". Если ваш плагин добавлен в кастомный тип полей, вы можете добавить slug в массив, например: <strong>1screens = array('post', 'my_portfolio');</strong>.</p>

<p><strong>Строка 9:</strong> - Здесь мы используем <strong>add_metaBox</strong> для создания панели.</p>

<p><strong>Строка 10:</strong> - Уникальный ID для нашего метабокса. Мы обратимся к этому позже, когда начнем создавать поля.</p>

<p><strong>Строка 11:</strong> - Отображение тайтла метабокса. Обратите внимание, если метабокс предназначено для публичного релиза, то эта строка должна быть интернационализирована с использованием <strong>_()</strong>.</p>

<p><strong>Строка 12:</strong> - Именование функции.</p>

<p><strong>Строка 13:</strong> - Тип поста, в котором должен отображаться метабокс. Так как мы используем переменную в строке 6, то установим переменную 1screen.</p>

<p><strong>Строка 14:</strong> - Определет раздел страницы, где должен располагаться метабокс (normal, advanced, side). 'normal' размещается под редактором.</p>

<p><strong>Строка 15:</strong> - Определяет порядок внутри секции, где матабокс будет размещен (high, core, default, or low). 'high' помещает метабокс выше Layers Options, прямо под редактором.</p>

<p>Теперь подключим нашу функцию в <strong><a href="https://developer.wordpress.org/reference/hooks/add_meta_boxes/" target="_blank">add_meta_boxes</a></strong>:</p>

<pre class="language-php"><code>add_action( 'add_meta_boxes', 'layers_child_add_meta_box' );</code></pre>

<p>Если вы добавите новый пост, то увидите созданный метабокс, хотя он еще будет пустой, пока не будет создана функция каллбек.</p>

<img src="../../public/images/blog/cms/layer-rukovodstvo/meta-box2.jpg" alt="Метабокс WordPress">

<h5>Создаем форму</h5>

<pre class="language-php"><code>/*
* Create Meta Callback - Prints the box content.
* @param WP_Post $post The object for the current post/page.
*/
function layers_child_meta_box_callback( $post ) {

// Add an nonce field so we can check for it later.
wp_nonce_field( 'layers_child_meta_box', 'layers_child_meta_box_nonce' );

/*
* Use get_post_meta() to retrieve an existing value
* from the database and use the value for the form.
*/
$credit_name = get_post_meta( $post->ID, 'my_photo_credit', true );
$credit_url = get_post_meta( $post->ID, 'my_credit_url', true );

// form elements go here

}
</code></pre>

<p><strong>Строка 5:</strong> - Создание каллбек функции.</p>

<p><strong>Строка 8:</strong> - Используйте <a href="https://developer.wordpress.org/reference/functions/wp_nonce_field/" target="_blank">wp_nonce_field</a> для настройки. Есть только 2 обязательных параметра:</p>

<ul>
  <li>Название экшена: Это может быть что угодно и просто добавляет контекст. Мы выводим мета опцию, поэтому мы просто выводим <strong>layers_child_meta_box</strong>. Должно быть уникальным</li>
  <li>Nonce Name: скрытое поле, мы сделали <strong>layers_child_meta_box_nonce</strong></li>
</ul>

<p><strong>Строки 14-15:</strong> - Здесь мы устанавливаем две переменные, которые представляют ключи наших мета полей с использованием <strong>get_post_meta</strong>, <strong>1credit_url</strong> и <strong>1credit_name</strong>, которые соответствуют нашим двум полям.</p>

<p>Мета данные обрабатываются парой ключ/значение. Ключ - это имя элемента метаданных. Значение - это информация, которая будет отображаться в списке метаданных каждого отдельного поста, с которым связана нформация.</p>

<p><strong>1post->ID</strong> - извлекает идентификатор поста, который создается, просматривается или запрашивается.</p>

<p><strong>'my_photo_credit'</strong> - второй параметр, имя мета ключа. Должно быть уникальным и семантическим.</p>

<p><strong>true</strong> используется для возвращения значения.</p>

<h5>Layers Form Elements</h5>

<p>Для наших целей нам нужны только два текстовых поля. Вы можете создать поле сообщения, значок/изображение, селектор, выбор файла, чекбокс, радиобаттон с использованием input(), а также, текстовые поля для использования специальных функций фреймворка.</p>

<pre class="language-php"><code>if( class_exists( 'Layers_Form_Elements' ) ) {
$form_elements = new Layers_Form_Elements();
//Photo Source
echo '&lt;p class="layers-form-item"&gt;';
echo '&lt;label&gt;'.__('Photo Source URL', 'layerswp').'&lt;/label&gt; ';
echo $form_elements-&gt;input(
  array(
    'type' =&gt; 'text',
    'name' =&gt; 'my_photo_credit',
    'id' =&gt; 'my_photo_credit',
    'placeholder' =&gt; __( 'Photo Source', 'layerswp' ),
    'value' =&gt; ( isset( $credit_name ) ? $credit_name : '' ),
    'class' =&gt; 'layers-text'
  )
);
echo '&lt;/p&gt;';
// Photo Source URL
echo '&lt;p class="layers-form-item"&gt;';
echo '&lt;label&gt;'.__('Photo Source URL', 'layerswp').'&lt;/label&gt; ';
echo $form_elements-&gt;input( 
  array(
    'type' =&gt; 'text',
    'name' =&gt; 'my_credit_url',
    'id' =&gt; 'my_credit_url',
    'placeholder' =&gt; __( 'Photo Credit URL', 'layerswp' ),
    'value' =&gt; ( isset( $credit_url ) ? $credit_url : '' ),
    'class' =&gt; 'layers-text'
  )
);
echo '&lt;/p&gt;';
} // Check Class
</code></pre>

<p><strong>Строки 1-2:</strong> - Мы начинаем с условия, которое проверяет, что Layers установлен. Это полезно для предотвращения ошибок, если пользователь забыл установить Layers.Установите значение <strong>1form_elements</strong> для новых <strong>Layers_Form_Elements</strong>.</p>

<p><strong>Строка 4: (необязательно)</strong> - Устанавливает враппер для поля. Использование параграфа с классовм <strong>layers-form-item</strong> растянет поле на всю ширину метабокса, как и поле "Video URL". Если вы не хотите использовать оболочку для полей, то они будут отображаться рядом друг с другом:</p>

<img src="../../public/images/blog/cms/layer-rukovodstvo/meta-box4.jpg" alt="Форма метабокса">

<p><strong>Строка 5: (необязательно)</strong> - Добавляет &lt;label&gt; для элементов, которые не понимают "label" аргумент. Лэйблы должны быть завернуты в <strong>__()</strong>.</p>

<p><strong>Строки 6-16:</strong> - Настройка массива input().</p>

<ul>
  <li>Обратите внимание, что мы ссылаемся на нашиимена ключей мета в каждом из имен инпутов и значений 'id'.</li>
  <li>Затем мы используем наши выходные переменные для установки <strong>'value'</strong> полей. При использовании <strong>isset</strong>, мы принимаем данные только в том случае, если они существуют: <strong>( isset( $credit_url ) ? $credit_url : '' )</strong></li>
  <li>И наконец, параметр 'class' позволяет использовать существующие стили для наших полей. Это необязательно - вы можете заменить ваш класс собственным, если угодно. Но имейте ввиду, что CSS админ панели должен быть загружен отдельно от Front-End CSS.</li>
</ul>

<h5>Поля TinyMCE</h5>

<p>Есть одно преимущество пользовательских полей перед кастомайзером - это поле редактирования с WYSIWYG редактором. В следующем примере мы все еще внутри нашей функции <strong>layers_child_meta_box_callback  function</strong>:</p>

<pre class="language-php"><code>$photo_description = get_post_meta( $post-&gt;ID, 'my_photo_desc', true );

/* Add WP Editor as replacement of textarea */
echo '&lt;p class="layers-form-item"&gt;';
echo '&lt;label&gt;'.__('Photo Description', 'layerswp').'&lt;/label&gt; ';
wp_editor( $photo_description, 'my_photo_desc', array(
  'wpautop'       =&gt; true,
  'media_buttons' =&gt; false,
  'textarea_name' =&gt; 'my_photo_desc',
  'textarea_rows' =&gt; 10,
  'teeny'         =&gt; true
) );
echo '&lt;/p&gt;';
</code></pre>

<img src="../../public/images/blog/cms/layer-rukovodstvo/mce-field.jpg" alt="TinyMCE WordPress Metabox">

<h4>Сохранение метаданных</h4>

<pre class="language-php"><code>function layers_child_save_meta_box_data( $post_id ) {
  // Checks save status
  $is_autosave = wp_is_post_autosave( $post_id );
  $is_revision = wp_is_post_revision( $post_id );
  $is_valid_nonce = ( isset( $_POST[ 'layers_child_meta_box_nonce' ] ) && wp_verify_nonce( $_POST[ 'layers_child_meta_box' ], basename( __FILE__ ) ) ) ? 'true' : 'false';
  
  // Exits script depending on save status
  if ( $is_autosave || $is_revision || !$is_valid_nonce ) {
    return;
  }
  
  // Checks for input and sanitizes/saves if needed
  if( isset( $_POST[ 'my_photo_credit' ] ) ) {
    update_post_meta( $post_id, 'my_photo_credit', sanitize_text_field( $_POST[ 'my_photo_credit' ] ) );
  }
  if( isset( $_POST[ 'my_credit_url' ] ) ) {
    update_post_meta( $post_id, 'my_credit_url', sanitize_text_field( $_POST[ 'my_credit_url' ] ) );
  }
}
</code></pre>

<p><strong>Строка 1:</strong> - Создание функции сохранения. То есть: <strong>yourtheme_custom_save_meta_box_data</strong>.</p>

<p>Перва часть функции проверяет, что мы действительно сохранить мета. Это предотвращает различные ошибки и определяет, что это действие не является автосохранением.</p>

<p><strong>Строка 5:</strong> - Первые <strong>&amp;_POST[]</strong> значения, которые должны быть установлены как nonce имя, которое мы определили ранее.</p>

<p>Вторая часть функции проверяет, введены ли какие-либо данные в двух полях, которые мы создали. Здесь используется функция <strong>update_post_meta()</strong> для сохраненя текста в базу данных. Эта функция имеет 4 параметра:</p>

<ul>
  <li><strong>$post_id</strong> = Уникальны идентификатор поста.</li>
  <li><strong>$meta_key</strong> = Уникальный ключ мета для сохранения. В нашем примере, ключами являются '<strong>my_photo_credit</strong>' и 'my_credit_url', которые мы определили ранее.</li>
  <li><strong>$meta_value</strong> = Значение, которое должно быть сохранено в базе.</li>
</ul>

<p><strong>Строки 13-17:</strong> - В коде выше установлен нужный <strong>1post_id</strong> и мета ключ для каждой функции <strong>update_post_meta</strong>.. Тем не менее, обратите внимание, что мы не задали значение мета напрямую. Вместо этого, мы использовали функцию <strong>sanitize_text_field</strong> с целью подготовки данных перед записью в базу данных. Если вы работаете с пользовательским вводом данных, вы не должны допустить размещение непроверенной информации в базу данных.</p>

<p>теперь вам нужно просто подключить ваш Хук в функцию <a href="https://developer.wordpress.org/reference/hooks/save_post/" target="_blank">save_post</a> и все готово!</p>

<pre class="language-php"><code>add_action( 'save_post', 'layers_child_save_meta_box_data' );</code></pre>

<p>Протестируйте ваш код, создавая новый пост, и заполнив ваши поля в метабоксе, затем нажмите кнопку "Сохранить черновик". Ваши данные должны быть сохранены после перезагрузки окна браузера на этой странице в админке. Если вы включите панель "Произвольные поля" в настройках экрана сверху, вы таже должны увидеть ключи и их значения:</p>

<img src="../../public/images/blog/cms/layer-rukovodstvo/custom-fields-saved.jpg" alt="Сохраненные произвольные поля в WordPress">

<h4>Подключение файла</h4>

<p>Всегда используйте <strong>require_once()</strong> для подключения файлов в PHP. Внимательно проверяйте путь до файла.</p>

<p>Добавьте ваш мета плагин в основной файл плагинов:</p>

<pre class="language-php"><code>require_once( 'includes/meta.php' );</code></pre>

<p>
  В файле <strong>functions.php</strong> для подключения файлов не забывайте использовать <strong>get_stylesheet_directory()</strong>
</p>

<pre class="language-php"><code>require_once( get_stylesheet_directory() . '/assets/my_filters.php' );</code></pre>

<h4>Отображение метаданных</h4>

<p>Теперь, когда мы успешно сохранили метаданные из метабокса, они могут быть отображены в любом месте, используя <strong>get_post_meta()</strong>, также, как мы это сделали выше. Это может быть сделано непосредственно в шаблоне или внутри функции, подключив Layers экшены.</p>

<pre class="language-php"><code>// Retrieves the stored value from the database
$photo_credit = get_post_meta( get_the_ID(), 'my_photo_credit', true );
$credit_url = get_post_meta( get_the_ID(), 'my_credit_url', true );

// Checks and displays the retrieved value
if( !empty( $photo_credit) ) { ?&gt;
&lt;span class="meta-info"&gt;
  &lt;a href="&lt;?php echo $credit_url; ?&gt;" target="_blank"&gt;&lt;?php echo $photo_credit; ?&gt;&lt;/a&gt;
&lt;/span&gt;
&lt;?php }
</code></pre>

<p><strong>Строки 2-3:</strong> - Определим переменные для наших полей. Убедитесь в правильности именований мета полей.</p>

<p><strong>Строка 6:</strong> - Проверяем существование значения. Это позволит избежать пустых элементов на странице.</p>

<p><strong>Строка 7:</strong> (не обязательно) - Здесь мы завернем наши мета данные в span с классом .meta-info.</p>

<h3>Настройка кастомайзера</h3>

<h4>Настройки по умолчанию</h4>

<h5>Панели, секции и контролы</h5>

<p>Чтобы понять, где появятся ваши настройки и какой элемент нужно будет добавить в админку Layers, давайте познакомимся с тем, что уже есть:</p>

<img src="../../public/images/blog/cms/layer-rukovodstvo/customizer1.jpg" alt="WordPress Customizer">

<ol>
  <li>Панель</li>
  <li>Секция</li>
  <li>Контрол</li>
  <li>Опция</li>
</ol>

<p><strong>Layers</strong> имеет набор инструментов для удобного и быстрого добавления новых пользовательских элементов в админ панель Кастомизатора.</p>

<ul>
  <li>layers_customizer_panels</li>
  <li>layers_customizer_sections</li>
  <li>layers_customizer_controls</li>
</ul>

<p>Вы можете добавлять пользовательские панели для размещения новых разделов и контролов или можете добавлять разделы и элементы управления в уже имеющиеся разделы.</p>

<h4>Структура фильтров</h4>

<h5>Плагины</h5>

<p>Ваши пользовательские функции контролов добавляются в класс плагина, после инициализации и после закрывающей скобки. Фильтры и кастомные функции, содержащие элементы управления в вашем плагине инициализируются конструктором.</p>

<p>Пример:</p>

<pre class="language-php"><code>public function init(){
  /**
  * Your regular plugin initialization code will go here
  */

  // Modify CSS Customizer Control
  add_filter( 'layers_customizer_controls', array( $this, 'my_customizer_controls' ) );

}

public my_customizer_controls( $controls ){
  // Custom customizer code will go here
}
</code></pre>

<h5>Дочерняя тема</h5>

<p>Ваша функция пользовательских элементов управления в дочерней теме открывается почти также, как расширение, но нуждается в публичной видимости.</p>

<p>Фильтры и кастомные функции, содержащие элементы управления пишутся в <strong>functions.php</strong> дочерней темы.</p>

<p>Пример:</p>

<pre class="language-php"><code>add_filter( 'layers_customizer_controls', 'my_layers_customizer_controls', 100 );

function layers_customizer_controls( $controls ){
  // Custom Customizer code will go here
}
</code></pre>

<p>Ниже объясняется каждый фильтр в деталях.</p>

<h5>Кастомные панели</h5>

<p>
  <strong>layers_customizer_panels</strong>
</p>

<pre class="language-php"><code>add_filter('layers_customizer_panels','layers_child_customizer_panels', 40);</code></pre>

<p>Второе значение является именем функции, третье - приоритет.</p>

<h5>Добавление кастомной панели</h5>

<pre class="language-php"><code>if( !function_exists( 'child_customizer_panels' ) ) {
  function child_customizer_panels( $panels ){
  $panels['theme-options'] = array(
    'title' => __( 'Theme Options' , 'child' ),
    'description'=> __( 'Your custom description.' , 'child' ),
    'priority' => 130
   );
   return $panels;
}
</code></pre>

<ul>
  <li><strong>Строка 1:</strong> - срока обеспечивает безопасность и проверяет наличие функции с таким-же именованием. Выбирая уникальные имена - вы избегаете конфликтов функций.</li>
  <li><strong>Строка 2:</strong> - Настройка вашей функции для изменения индекса $panels</li>
  <li><strong>Строка 3:</strong> - Устанавливает ключ или имя панели, т.е. 'theme-options'. Они должны быть в нижнем регистре и использовать только черточку или нижнее подчеркивание.</li>
  <li><strong>Строка 4:</strong> - Устанавливает '<strong>title</strong>' для вашего раздела, который отображается в кастомайзере. Строки всегда должны использовать метод <strong><a href="https://codex.wordpress.org/L10n" target="_blank">l10n </a></strong>, т.е. <strong>__(‘string’, ‘textdomain’)</strong></li>
  <li><strong>Строка 5:</strong> - Устанавливает '<strong>description</strong>' (опционально). Это небольшой текст, который можно использовать для разъяснения.</li>
  <li><strong>Строка 6:</strong> - Устанавливает приоритет, который является числовым значением, определяющим, где панель размещается в списке. Значение 130 является безопасным выбором, поскольку это гарантирует, что ваши панели будут размещены ниже базовых панелей Layers.</li>
</ul>

<h5>Кастомные секции</h5>

<p>
  <strong>layers_customizer_sections</strong>
</p>

<pre class="language-php"><code>add_filter('layers_customizer_sections','layers_child_customizer_sections', 100);</code></pre>

<p>Второе значение является именем функции, третье - приоритет. 100 - это хороший выбор.</p>

<h5>Добавление кастомной секции</h5>

<p>У каждого раздела должны быть определены названия, чтобы панель была добавлена. Пример показывает, как добавить кастомную секцию header-social-media (Social Media Profiles) на вашу кастомную панель theme-options.</p>

<pre class="language-php"><code>if( !function_exists( 'child_customizer_sections' ) ) {
   function child_customizer_sections( $sections ){
    $sections[ 'header-social-media' ] = array(
    'title' => __( 'Social Media Profiles' , 'child' ),
    'panel' => 'theme-options',
    );
    return $sections;
   }
}
</code></pre>

<h5>Добавление секции на существующую панель</h5>

<p>Пример показывает, как добавить нашу кастомную секцию header-social-media (Social Media Profiles) на существующую панель Layers. Главное отличие от предыдущего - наличие <strong>array_merge</strong>, который принимает вашу секцию и размещает с существующими.</p>

<pre class="language-php"><code>if( !function_exists( 'child_customizer_sections' ) ) {
   function child_customizer_sections( $sections ){
    $sections[ 'header-social-media' ] = array(
    'title' => __( 'Social Media Profiles' , 'layerswp' ),
    'panel' => 'header',
    );

    $sections = array_merge( $sections, $sections[ 'header-social-media' ] );
    return $sections;
  }
}
</code></pre>

<p>Панели, созданные для Layers:</p>

<ul>
  <li>Панель: Header <strong>header</strong></li>
  <li>Панель: Footer <strong>footer</strong></li>
  <li>Панель: WooCommerce <strong>woocommerce</strong></li>
</ul>

<h5>Кастомные контролы</h5>

<p>
  <strong>layers_customizer_controls</strong>
</p>

<pre class="language-php"><code>add_filter('layers_customizer_controls','layers_child_customizer_controls', 100);</code></pre>

<p>Второе значение является именем функции, третье - приоритет. 100 - это хороший выбор приоритета.</p>

<p>Базовая структура контрола:</p>

<pre class="language-php"><code>function yourtheme_customizer_controls( $controls ){
  $controls[ 'section-name' ] = array(
    'option-one' => array(
     'type' => 'layers-text',
     'label' => __( 'Option One' , 'mytheme_textdomain' )
    ),
    'option-two' => array(
     'type' => 'layers-text',
     'label' => __( 'Option Two' , 'mytheme_textdomain' )
     )      
  );
  return $controls;
}
</code></pre>

<p>Каждый контрол использует массив, чтобы объявить себя, то-есть <strong>option-one</strong><strong>option-two</strong> и так далее.</p>

<h5>Добавление кастомного контрола</h5>

<p>Пример показывает, как добавить некоторые текстовые поля для ввода URL в кастмную секцию header-social-media:</p>

<pre class="language-php"><code>if( !function_exists( 'child_customizer_controls' ) ) {
  function child_customizer_controls( $controls ){
  $controls[ 'header-social-media' ] = array(
    'social-twitter' => array(
     'type' => 'layers-text',
     'label' => __( 'Twitter Username' , 'child' )
    ),
    'social-facebook' => array(
     'type' => 'layers-text',
     'label' => __( 'Facebook Vanity URL' , 'child' )
     ),
    'social-pinterest' => array(
      'type' => 'layers-text',
      'label' => __( 'Pinterest Username' , 'child')
    )
  );
  return $controls;
  }
}
</code></pre>

<p>
  <strong>type</strong> - Определение типа контрола: <strong>'type' => 'layers-text'</strong>
</p>

<p>Смотрите <strong>layers_customizer_controls</strong> для просмотра всех доступных типов.</p>

<p><strong>label</strong> - Заголовок. Должен использовать метод <a href="https://codex.wordpress.org/L10n" target="_blank">l10n</a> <strong>__()</strong> для обертки значения.</p>

<pre class="language-php"><code>'label' => __( 'Choose Background' , 'layerswp' )</code></pre>

<strong>placeholder</strong> - Использует комбинацию с типами <strong>layers-text</strong>, <strong>layers-textarea</strong>, <strong>layers-rte</strong> или <strong>layers-code</strong>, и устанавливает текст по умолчанию внутри области, чтобы использовать в качестве примера.

<pre class="language-php"><code>'placeholder' => "Enter URL",</code></pre>

<p><strong>description</strong> - Длинный текст описания(опционально).</p>

<pre class="language-php"><code>'description' => sprintf( __( 'For more information, see &lt;a href="%s" target="_blank"&gt;follow this link&lt;/a&gt;.', 'yourtheme_textdonmain' ), 'https://www.your-url.com' ),
</code></pre>

<p><strong>choises</strong> - используется в комбинации с <strong>type</strong> для определения выпадающих опций. Пример ниже показывает, как мы добавляем опцию Области Виджета с использованием типа layers-select и заполняем пункты 4-мя вариантами.</p>

<pre class="language-php"><code>'footer-sidebar-count' => array(
  'type' => 'layers-select',
  'label' => __( 'Widget Areas' , 'layerswp' ),
  'default' => 4,
  'sanitize_callback' => 'layers_sanitize_number',
  'choices' => array(
    '0' => __( 'None' , 'layerswp' ),
    '1' => __( '1' , 'layerswp' ),
    '2' => __( '2' , 'layerswp' ),
    '3' => __( '3' , 'layerswp' ),
    '4' => __( '4' , 'layerswp' ),
    )
) // layout
</code></pre>

<h4>Добавление контролов в существующие секции</h4>

<p>Этот пример показывает, как добавить текстовые поля для профилей в социальных медиа в Header (header-layout) - секцию, которая уже есть в Layers.</p>

<p>
  Вы можете посмотреть доступные наименования ключей для секций Layers в массиве <strong>sections</strong>: <a href="https://github.com/Obox/layerswp/blob/master/core/customizer/config.php#L220" target="_blank">core/customizer/config.php</a>
</p>

<pre class="language-php"><code>if( !function_exists( 'mytheme_customizer_controls' ) ) {
   function mytheme_customizer_sections( $controls){
    $social_media_controls = array(
     'social-twitter' => array(
      'type'  => 'layers-text',
      'label' => __( 'Twitter Username' , 'mytheme_textdodmain' ),
    ),
     'social-facebook' => array(
      'type'  => 'layers-text',
      'label' => __( 'Facebook Vanity URL' , 'mytheme_textdodmain' ),
    ),
     'social-pinterest' => array(
      'type'  => 'layers-text',
      'label' => __( 'Pinterest Username' , 'mytheme_textdodmain' ),
    ),
  );

  $controls['header-layout'] = array_merge( $controls['header-layout'], $social_media_controls );

  return $controls;
  }
}
</code></pre>

<p>Следующие панели и секции уже существуют в Layers и могут быть расширены путем добавления кастомных элементов управления в соответствующем разделе:</p>

<ul><li>Панель: Настройки сайта <strong>site-settings</strong>
<ul><li>Секция: Логотип &amp; Заголовок <strong>title_tagline</strong></li>
<li>Секция: Меню <strong>nav</strong></li>
<li>Секция: Site Colors <strong>site-colors</strong></li>
<li>Секция: Sidebars <strong>content-sidebars</strong></li>
<li>Секция: Шрифты <strong>fonts</strong></li>
</ul></li>
<li>Панель: Верхняя часть сайта <strong>header</strong>
<ul><li>Секция: Макет <strong>eader-layout</strong></li>
<li>Секция: Дополнительные скрипты <strong>header-scripts</strong></li>
</ul></li>
<li>Панель: Нижняя часть сайта <strong>footer</strong>
<ul><li>Секция: Макет <strong>footer-layout</strong></li>
<li>Секция: Customization <strong>footer-customization</strong></li>
<li>Секция: Текст <strong>footer-text</strong></li>
<li>Секция: Дополнительные скрипты <strong>footer-scripts</strong></li>
</ul></li>
<li>Панель: WooCommerce <strong>woocommerce</strong></li>
</ul>

<p>WordPress предлагает следующие значения по умолчанию:</p>

<p><strong>title_tagline</strong> – Название и слоган</p>
<p><strong>colors</strong> – Цвета</p>
<p><strong>header_image</strong> – Изображение заголовка</p>

<h5>Настройка селекторов для управления цветом</h5>

<p>Если у вас есть настройки кастомного контрола с типом layers-color, вам нужно булет связать его с элементом, для этого нужно изменить, а затем вывести CSS, правильно используя <strong>layers_inline_styles</strong>. Это гарантирует, что опции, выбранные в кастомайзере переопределят абсолютно все другие свойства. Также это позволяет подключиться к контролу <strong>invert</strong>, который помогает автоматически регулировать текстовые цвет текста, в зависимости от того, светлую тему фона выбрал пользователь, или темную.</p>

<p>Добавим инъекцию layers_apply_customizer_styles().</p>

<pre class="language-php"><code>add_action( 'wp_enqueue_scripts', 'layers_child_customizer_styles', 100 );</code></pre>

<p>Первое значение <strong>wp_enqueue_scripts</strong> позволяет подключить вашу функцию  в уже существующую линейку скриптов и даст WordPress управлять системой, если что-то пойдет не так. Второе значение определяет имя функции, а третья - приоритет. 100 явлется безопасным выбором и важнее авторских плагинов.</p>

<pre class="language-php"><code>if( !function_exists( 'layers_child_customizer_styles' ) ) {
  function layers_child_customizer_styles() {
    $widget_title_color = layers_get_theme_mod(
      'widget-title-color' ,
       TRUE
    );
    if( '' != $widget_title_color ) {
      layers_inline_styles( array(
      'selectors' => array( '.sidebar .section-nav-title'),
        'css' => array(
        'color' => $widget_title_color,
        ),
      ));
    }
  }
}
</code></pre>

<p>
  <strong>Строка 2:</strong> - Создаем новую функцию <strong>layers_child_customizer_styles</strong>
</p>

<p><strong>Строка 3:</strong> - Устанавливаем переменную <strong>1widget_title_color</strong>, которая будет представать пред взором пользователя для выбора. Мы используем <strong>layers_get_theme_mod()</strong> для захвата кастомного элемента управления <strong>widget-title-color</strong>, который определяется в строке 4.</p>

<p><strong>Строка 5:</strong> - <strong>TRUE</strong> соответствует <strong>allow_empty</strong> и может оставаться пустым.</p>

<p><strong>Строка 7:</strong> - Если пусто - инлайновые CSS выводиться не будут.</p>

<p>
  <strong>Строка 8:</strong> - Наконец, устанавливаем инлайновый CSS <strong>layers_inline_styles()</strong>
</p>

<p>Этот код должен располагаться в <strong>functions.php</strong> или внутри класса вашего плагина, где идут все остальные пользовательские Хуки, а не внутри функций кастомных контролов, секций или панелей.</p>

<h4>Использование опций во фронтенде</h4>

<p>Чтобы использовать настройки во фронтенде Layers, мы используем вспомогательную функцию <strong>layers_get_theme_mod()</strong>, которая работает также, как основной <strong>get_option()</strong> WordPress.</p>

<p>В следующем примере мы добавим наши новые элементы управления в заголовке Layers, используя фильтр <strong>  the layers_before_header_nav</strong>. Этот код располагается в <strong>functions.php</strong> или плагине, где используются остальные Хуки.</p>

<pre class="language-php"><code>add_action( 'layers_before_header_nav' , 'my_header_social_media_icons' );

function my_header_social_media_icons(){ ?&gt;
     &lt;div class="pull-right"&gt;
      &lt;?php if( '' != layers_get_theme_mod( 'social-facebook' ) { ?&gt;
         &lt;a href="https://facebook.com/&lt;?php echo layers_get_theme_mod( 'social-facebook' ); ?&gt;"&gt;&lt;i class="i-facebook"&gt;facebook&lt;/i&gt;&lt;/a&gt;
      &lt;?php } ?&gt;
      &lt;?php if( '' != layers_get_theme_mod( 'social-twitter' ) { ?&gt;
        &lt;a href="https://twitter.com/&lt;?php echo layers_get_theme_mod( 'social-twitter' ); ?&gt;"&gt;&lt;i class="i-facebook"&gt;facebook&lt;/i&gt;&lt;/a&gt;
      &lt;?php } ?&gt;
      &lt;?php if( '' != layers_get_theme_mod( 'social-pinterest' ) { ?&gt;
        &lt;a href="https://pinterest.com/&lt;?php echo layers_get_theme_mod( 'social-pinterest' ); ?&gt;"&gt;&lt;i class="i-pinterest"&gt;pinterest&lt;/i&gt;&lt;/a&gt;
      &lt;?php } ?&gt;
     &lt;/div&gt;
  &lt;?php };
}
</code></pre>

<h4>Прессеты</h4>

<p>Layers бладает возможностью экспортировать каждую страницу по отдельности и упаковывать их вместе с пользовательскими CSS и XML экспортом при создании <strong>StyleKit</strong>, благодаря этому пользователи могут импортировать полностью настроенные макеты страниц. Если у вас уже есть дочерняя тема, то это не нужно упаковывать. Вместо этого вы можете интегрировать прессеты непосредственно в тему путем фильтрации хука <strong>layers_preset_layouts</strong>. Это устанавливает прессеты в Layers в области добавления новой страницы, позволяя пользователям выбрать один из кастомных макетов и загрузить его в один клик, по сравнению с количеством действий, при импорте StyleKit.</p>

<h4>Настройка изображений</h4>

<p>Ваши подготовленные изображения должны быть сохранены в специальной папке, внутри дочерней темы, для того, чтобы они могли быть автоматически получены при загрузке XML данных.</p>

<p>Изображения, используемые в качестве фона или для полной ширины слайдов должны быть по ширине не менее 1920px. Изображения, используемые в других местах, должны быть по ширине не менее 1000px. Это гарантирует, что ваша тема будет достойно отображать ваши изображения на различных устроствах при масштабировании контента. Какждый пресет должен быть снабжен скриншотом <strong>screenshot.png/jpg</strong>, шириной 515px и высотой 350px.</p>

<ul>
  <li>В папке вашей дочерней темы должна существовать папка <strong>/assets</strong>.</li>
  <li>Создайте в папке /assets папку <strong>/preset-images</strong>.</li>
  <li>Добавьте все картинки, используемые в пресетах в данную папку.</li>
</ul>

<h4>Настройка демо данных</h4>

<p>
  Прежде, чем интегрировать пресет, вам необходимо настроить вашу дочернюю тему и страницы Layers. Лучше, конечно, сделать это на реальном сервере, если вам необходимо экспортировать содержимое в XML файл, иначе ваши покупатели лишатся возможности импорта изображений с удаленного сервера. Также убедитесь, что все изображения загружены в папку <strong>/assets/preset-images</strong>
</p>

<h4>Экспорт данных</h4>

<p>Для экспорта страниц, используйте функцию экспорта в самом редакторе страниц. Создастся <strong>.json</strong> файл макета. Экспортируйте каждую страницу в отдельный .json файл.</p>

<h4>Настройка функций</h4>

<p>Вы можете добавлять свои пользовательские стили в файл <strong>functions.php</strong> вашей темы, но json структура может обрабатываться слишком долго, поэтому можно создать вспомогательный файл <strong>preset.php</strong>, который включаетс в functions.php посредством <strong>require_once()</strong>. Данный функционал срабатывает при добавлении новой страницы Layers.</p>

<pre class="language-php"><code>require_once get_stylesheet_directory() . '/includes/presets.php';</code></pre>

<p>В вашем preset.php определите фильтр:</p>

<pre class="language-php"><code>add_filter( 'layers_preset_layouts', 'layers_child_presets', 0 );</code></pre>

<p>В данном примере мы используем <strong>layers_child_presets</strong> как нашу пользовательскую функцию, где <strong>child</strong> может быть наименование вашей темы. Давайте взгляним на функцию:</p>

<pre class="language-php"><code>function layers_child_presets( $layers_preset_layouts ) {

  $layers_child_presets[ 'first-preset-id' ] = array(
    'title' => __( 'My Child Theme - Home', 'child-theme-slug' ),
    'screenshot' => get_stylesheet_directory_uri().'/assets/preset-images/home-preset.png',
    'screenshot_type' => 'png',
    'json' => ''
  );

  return array_merge( $layers_child_presets, $layers_preset_layouts );
}
</code></pre>

<p><strong>Строка 1: Фильтр 1layers_preset_layouts</strong> - </p>

<p>Выбор функции 1layers_preset_layouts и определение собственной переменной 1layers_child_presets позволит нам создать свой массив в Layers.</p>

<p>
  <strong>Строка 3: first-preset-id</strong>
</p>

<p>Это начало нашего массива, который должен иметь уникальный идетнификатор для пресета. Здесь мы используем первый заданный идентификатор, но ваш может быть <strong>my-child-home-preset</strong>.</p>

<p>
  <strong>Строка 4: Заголовок пресета</strong>
</p>

<p>Аргумент заголовка - это простая строка, используемая с __(), для того, чтобы данный текст мог быть <a href="https://developer.wordpress.org/reference/hooks/gettext/" target="_blank">переведен на другие языки</a>. <strong>child-theme-slug</strong> - это основной слаг, определенный в функции локализации.</p>

<p>
  <strong>Строка 5: URL скриншота</strong>
</p>

<p>Для лучшей производительности храните скриншот в папке <strong>/assets/preset-images</strong>. Мы используем <strong>get_stylesheet_directory_uri()</strong> для того, чтобы получить корень дочерней темы, которую мы создали.</p>

<p>
  <strong>  Строка 7: Json</strong>
</p>

<p>Аргумент <strong>json</strong> просматривает все содержимое вашего файла экспорта, который указан в кавычках.</p>

<p>
  <strong>Строка 10: Возврат</strong>
</p>

<p>Наконец, мыобъединяем наши массивы посредством <strong>array_merge()</strong> и возвращаем результат.</p>

<p>
  <strong>Тестируйте!</strong>
</p>

<p>Активируйте вашу дочернюю тему на свежеустановленном WordPress.</p>
<p>Перейдите Layers -> Добавить страницу и убедитесь, что появляются ваши пресеты.</p>

<h4>Главная и другие страницы админки WordPress</h4>

<p>На главной странице админки WordPress вы можете разместить интерактивный гайд, который поможет пользователю начать работу с темой или плагином. В Layers и оффициальных расширениях это делается с помощью активации "setup wizard", который проводит пользователя через несколько кратких шагов, начиная с видео и заканчивая Кастомайзером, где пользователи могут начать использовать фреймфорк.</p>

<h5>Ссылки Admin Menu</h5>

<a href="https://developer.wordpress.org/reference/functions/add_submenu_page/" target="_blank">add_submenu_page()</a>

<h5>Внутри плагина:</h5>

<pre class="language-php"><code>public function add_submenu_page(){
  add_submenu_page(
    'layers-dashboard',
    __( 'Demo Extension Help' , LAYERS_DEMO_EXTENSION_SLUG ),
    __( 'Demo Extension Help' , LAYERS_DEMO_EXTENSION_SLUG ),
    'edit_theme_options',
    'layers-demo-extension-get-started',
    array( $this, 'load_onboarding' )
  );
}

public function load_onboarding(){
   require LAYERS_DEMO_EXTENSION_DIR .'includes/onboarding.php';
}
</code></pre>

<p><strong>Строка 3:</strong> - Слаг меню Layers с <strong>layers-dashboard</strong>.</p>

<p><strong>Строка 4:</strong> - Название страницы, заключенное в __() для перевода.</p>

<p><strong>Строка 5:</strong> - Название нашей ссылки в меню, заключенное в __() для перевода.</p>

<p><strong>Строка 7:</strong> - слаг страницы. Убедитесь, что используется уникальный Слаг. Не называйте например так: settings или get-started, это плохой вариант.</p>

<p><strong>Строка 8:</strong> - Каллбек.</p>

<p><strong>Строка 12:</strong> - Функция <strong>load_onboarding</strong> просто захватывает наш шаблон страницы Onboarding.</p>

<p><strong>Строка 13:</strong> - Мы используем <strong>require</strong> для подключения частей в хедер и футер. Наш постоянный DIR - это константа, используемая для получения пути к папке плагина.</p>

<p>Теперь подключим к <strong><a href="https://developer.wordpress.org/reference/hooks/admin_menu/"  target="_blank">admin_menu</a></strong> из вашего __construct() и зададим приоритет 60.</p>

<pre class="language-php"><code>add_action( 'admin_menu', array( $this, 'add_submenu_page' ), 60 );</code></pre>

<p>
  <strong>Внутри functions.php в дочерней теме:</strong>
</p>

<pre class="language-php"><code>if( ! function_exists('register_layers_child_submenu_page') ) {
  function register_layers_child_submenu_page(){
    add_submenu_page(
    'layers-dashboard',
    __( 'Layers Child Help' , 'layers-child' ),
    __( 'Layers Child Help' , 'layers-child' ),
    'edit_theme_options',
    'layers-child-get-started',
    'get_child_onboarding'
    );
  }
}

function get_child_onboarding(){
  require_once get_stylesheet_directory() . '/includes/theme-help.php';
}

add_action('admin_menu', 'register_layers_child_submenu_page', 60);
</code></pre>

<h4>Admin Страницы</h4>

<p>Для обоих Onboarding или free-form страниц админки, ваш шаблон требует только одну вещь - это обертку с классом <strong>layers-area-wrapper class</strong>:</p>

<pre class="language-html"><code>&lt;section class="layers-area-wrapper"&gt;

  // Your Admin Page markup goes here

&lt;/section&gt;
</code></pre>

<p>Что вы поместите внутрю такой обертки - решать вам, но соблюдайте основные правила:</p>

<ol>
  <li>Ваша админ страница не должна конкурировать непосредственно с Layers Marketplace (но можно, конечно, перелинковать свои продукты для демонстрации).</li>
  <li>Не размещайте какие либо элементы настройки фронтенда в данную страницу, все настройки должны быть размещены в Кастомайзер.</li>
</ol>

<p>В большинстак случаев, дочерние темы Layers не нуждаются в дополнительном Onboarding и будут сразу отправлены в мастер основных настроек, но вы можете все-таки использовать свой экран приветствия, как способ создавать свои справочные материалы, гайды и введения.</p>

<img src="../../public/images/blog/cms/layer-rukovodstvo/onboarding.jpg" alt="WoedPress Onboarding">

<h4>Редирект на активацию</h4>

<h5>Плагины</h5>

<p>Во-первых, мы используем <strong>set_transient()</strong> для создания перенаправления и задаем приоритет 30, чтобы обеспечить установку после того, как Layers загружен:</p>

<pre class="language-php"><code>public function demo_extension_active() {
  set_transient( 'layers_demo_extension_activated', 1, 30 );
}
</code></pre>

<p>Затем настраиваем редирект:</p>

<pre class="language-php"><code>public function demo_extension_onboard_redirect() {

  if ( ! current_user_can( 'manage_options' ) ) return;
  if ( ! get_transient( 'layers_demo_extension_activated' ) ) return;

  wp_redirect( admin_url( 'admin.php?page=layers-demo-extension-get-started' ) );

}
</code></pre>

<p><strong>Строка 3:</strong> - Мы используем <strong><a href="https://developer.wordpress.org/reference/functions/current_user_can/" target="_blank">current_user_can()</a></strong> для того, чтобы установить минимальную совместимость с manage_options для этой страницы, которая будет отображаться.</p>

<p><strong>Строка 4:</strong> - Здесь мы используем <strong><a href="https://developer.wordpress.org/reference/functions/get_transient/" target="_blank">get_transient()</a></strong> для проверки процесса <strong>layers_demo_extension_activated</strong>. Это гарантирует, что действие происходит только при активации темы.</p>

<p><strong>Строка 6:</strong> - Вместе с <a href="https://developer.wordpress.org/reference/functions/wp_redirect/" target="_blank">wp_redirect</a> va можем использовать <a href="https://developer.wordpress.org/reference/functions/admin_url/" target="_blank">admin_url</a> для того, чтобы задать путь к нашей странице в Слаге, который мы определили ранее в функции <strong>add_submenu_page</strong>.</p>

<p>В финале мы делаем инъекцию нашего творчества в <strong>__contruct()</strong>:</p>

<pre class="language-php"><code>register_activation_hook( LAYERS_DEMO_EXTENSION_FILE , array( $this, 'activate' ) );
add_action( 'init' , array( $this, 'demo_extension_onboard_redirect') );
</code></pre>

<h4>Дочерние темы</h4>

<p>Дочерние темы будут перенаправлять на Layers Getting Started по умолчанию. Мы действительно рекомендуем сохранить это в таком виде дл пользователей, которые никогда не использовали <strong>Layers</strong>, вы можетеперенаправить пользователя на вашу страницу с помощью <strong>wp_safe_redirect()</strong> внутри functions.php</p>

<pre class="language-php"><code>function layers_child_setup() {
  if( isset($_GET["activated"]) && $pagenow = "themes.php" ) {
    update_option( 'layers_welcome' , 1);
    wp_safe_redirect( admin_url('admin.php?page=layers-child-get-started'));
  }
}
add_action( 'after_setup_theme' , 'layers_child_setup', 30 );
</code></pre>

<p><strong>Строка 2:</strong> - Проверяет, только что ли активирована тема на странице Темы. Если так, то:</p>

<p><strong>Строка 3:</strong> - Установите опции <strong>layers_welcome</strong> значение 1 (true) - это опция, созданная Layers Core.</p>

<p><strong>Строка 4:</strong> - <strong><a href="https://developer.wordpress.org/reference/functions/wp_safe_redirect/" target="_blank">wp_safe_redirect</a></strong> в <a href="https://developer.wordpress.org/reference/functions/admin_url/" target="_blank">admin_url</a> использует Слаг страницы, который мы определили ранее в нашей функции <strong>Line 7: Hook our function into after_setup_theme and give it a priority of 30 to ensure it runs after Layers.</strong>.</p>

<p><strong>Строка 7:</strong> - Подключаем наху функцию в <a href="https://developer.wordpress.org/reference/hooks/after_setup_theme/" target="_blank">after_setup_theme</a> и задаем приоритет 30, для запуска после Layers.</p>

<h4>Поддержка языков</h4>

<p>Для добавления перевода в вашу дочернюю тему, для начала зарегистрируйте <a href="https://developer.wordpress.org/reference/functions/load_child_theme_textdomain/" target="_blank">текстдомэйн</a> в вашем functions.php</p>

<p>Самый простой способ подготовить свой перевод - это использовать плагин, типа <strong>Loco Translate</strong>. Вы также можете подготовить эти переводы с помощью <a href="https://poedit.net/" target="_blank">Poedit</a>. Посмотрите <a href="https://make.wordpress.org/polyglots/handbook/translating/expectations/" target="_blank">Translation tips</a> для того, чтобы узнать о том, как сделать хороший перевод темы на другие языки. Ваши <strong>.po</strong> и <strong>.mo</strong> файлы должны быть сохранены в папке <strong>/languages</strong> вашей дочерней темы.</p>

<h3>Продажа тем</h3>

<p><strong>Layers</strong> - это уникальный билдер страниц и сайтов и фреймворк для создания тем для WordPress. Дочерние темы для Layers и наборы пресетов (StyleKit) можно продавать на <a href="https://themeforest.net/attributes/framework/layers%20wp" target="_blank">ThemeForest</a>.</p>

<h4>Требования к загрузке на ThemeForest</h4>

<ul>
  <li>Дочерние темы Layers должны <a href="https://help.author.envato.com/hc/en-us/articles/360000472383" target="_blank">соответствовать всем стандартам для загрузки тем на ThemeForest</a>.</li>
  <li>LayersWP Framework не должен быть включен в в дочернюю тему в Zip архиве. Вмето этого сделайте ссылку на скачивание Layers в документации к теме.</li>
  <li>Дочерние темы должны включать файл index.php, иначе они не смогут быть загружены на ThemeForest. Файл <strong>index.php</strong> должен выглядеть следующим образом:
<pre class="language-php"><code>&lt;?php
// load the parent index.php file

require_once( get_template_directory() . '/index.php' );
</code></pre>
Ни больше. Ни меньше.
  </li>
</ul>

<p>Товар должен включать следующее описание на ThemeForest, чтобы покупатели знали, что он работает с Layers.</p>

<pre class="language-php"><code>&lt;a href="https://all-marketplaces.s3.amazonaws.com/growth/layers/layerswp.zip"&gt;
&lt;a href="https://enva.to/-onzw"&gt;&lt;img src="https://all-marketplaces.s3.amazonaws.com/growth/layers/landing-badge-small.png"&gt;&lt;/a&gt;
</code></pre>

<h4>Технические требования</h4>

<ul>
  <li>Дочерняя тема должна удовлетворять следующей структуре файлов и папок, в качестве основы нужно брать родительскую тему Layers, как в данном примере:</li>
</ul>

<ul>
  <li>Папка дочерней темы /
  <ul>
  <li>assets /
    <ul>
    <li>preset-images/</li>
      <li>css /</li>
      <li>images /</li>
      <li>js /
        <ul><li>theme.js</li>
        </ul></li>
      </ul></li>
      <li>languages /</li>
      <li>partials /</li>
      <li>functions.php</li>
      <li>style.css</li>
  </ul>
</ul>

<h4>CSS и стилизация</h4>

<ul>
  <li>Правила CSS должны быть достаточно конкретными для переопределения Layers CSS.</li>
  <li>Шрифтовые библиотеки могут быть загружены из CDN источника дл снижения нагрузки на сервер.</li>
  <li><strong>Обратите внимание:</strong> Шрифты Google Fonts уже включены в Layers Framework.</li>
  <li>Шрифтовые иконки должны быть размещены в подпапке <strong>/assets</strong> дочерней темы.</li>
  <li>Дополнительные стили шрифтов и @font-face CSS должны храниться в отдельном файле <strong>fonts.css</strong></li>
  <li><strong>fonts.css</strong> должен быть загружен до основный стилей дочерней темы.</li>
  <li>Layers Кастомайзер должен быть настроен по умолчанию в <strong>functions.php</strong>, чтобы предопределить настройки сайта.</li>
</ul>

<h4>JavaScript</h4>

<ul>
  <li>Дополнительные скрипты должны размещаться в папке <strong>assets/js</strong> дочерней темы.</li>
  <li>Вы не должны менять скрипты Layers в родительской теме и не должны копировать куски кода оттуда. Вместо этого используйте API и подключайте корректировки в файле assets/js/theme.js</li>
</ul>

<h4>PHP и шаблоны</h4>

<ul>
  <li>Включение отдельных PHP файлов и библиотек должно быть сделано с помощью <strong>require_once()</strong> из файла <strong>functions.php</strong> дочерней темы.</li>
  <li>Любые шаблоны страниц, загруженные в дочерней теме, должны использовать базовую структуру шаблонов Layers HTML, такие-же классы и функции для вывода элементов, таких, как Сайдбары (как в шаблонах Layers по умолчанию).</li>
  <li>
    Дочерняя тема не должна изменя соответствующие элементы в существующих шаблонах Layers:
    <ul>
      <li>Не изменяйте типы заголовков шаблона. Заголовки были оптимизированы для SEO.</li>
      <li>Не отходите от HTMl стайлинга Layers Framework (например, не изменяйте &lt;section&gt;). Разрешено добавление элементов, но не удаление стандартных.</li>
      <li>не удаляйте классы по умолчанию или вызовы функций внутри врапперов, так как это может нарушить функциональность и настройки фреймворка.</li>
      <li>Не используйте <strong>query_posts()</strong> функцию для модификации стандартного запроса.</li>
    </ul>
  </li>
  <li>При регистрации новый сайдбаров, вы не должны использовать простые номера или родные ID значения, такие, как <strong>"sidebar"</strong>, <strong>"widget-area"</strong> или <strong>"widgets"</strong>. Идентификаторы сайдбаров должны писаться в нижнем регистре и использовать дефисы, чтобы отделить слова.</li>
  <li>Области кастомных виджетов должны использовать условия проверки "is_active_sidebar", чтобы избежать конфликтов.</li>
  <li>Дочерние темы не должны вводить какой-либо функционал по работе с контентом, например таке, как Custom Post Types, Custom Taxonomies, shortcodes и так далее. Вместо этого - вы должны обрабатывать дополнительный функционал в отдельных плагинах, которые могут быть упакованы вместе с вашей дочерней темой или предлагаться как аддон.</li>
</ul>

<p>
  Дочерние темы могут включать в себя дополнительные пресеты для увеличения производительности генератора макетов. Все изображения, используемые в шаблоне, должны быть добавлены в папку <strong>assets/preset-images</strong>
</p>

<h4>Продажа</h4>

<p>Наш официальный маркетплейс - это <a href="https://themeforest.net/" target="_blank">ThemeForest</a>. Ознакомьтесь с требованиями перед добавлением темы <a href="https://help.author.envato.com/hc/en-us/articles/360000472283" target="_blank">На этой странице</a>.</p>

<p>Как Open-Source фрэймворк, мы не можем ограничить то, что вы хотите продать и где вы хотите продать. Но ThemeForest является единственной площадкой, где официально поддерживается фреймворк Layers и местом, где продаются продукты, созданные с использованием Layers.</p>

<p>Вы, конечно, можете продавать свои дочерние темы через другие магазины или ваш собственный сайт, но продавая на ThemeForest вы будете обеспечены поддержкой вашего продукта и дстаточно обширной аудиторией, что является огромным преимуществом при старте.</p>

<h4>Требования к документации</h4>

<p>Все темы на ThemeForest должны быть задокументированы, чтобы покупателям было проще установить и настроить тему.</p>

<ul>
  <li>Пожалуйста, ознакомьтесь с <a href="https://help.author.envato.com/hc/en-us/articles/360000470826" target="_blank">ThemeForest General File Preparation Guidelines</a>, чтобы понять, как оформляются справочные материалы темы.</li>
  <li>Вы должны быть ответственны за поддержку покупателей дочерней темы, включа установку, настройку, обновлений и поиск неисправностей.</li>
</ul>


                <div class="premium">
          <div class="row">

            <div class="col-md-12">
              <h4>Премиум уроки от WebDesign Master</h4>
            </div>

            <div class="col-md-4 col-sm-6">
              <a href="../../courses/jekyll/index.html" class="premium-item">
                <span class="premium-img-wrap"><img src="../../public/images/premium/jekyll.jpg" alt="Курс по созданию сайта от А до Я на Jekyll" class="img-responsive"></span>
                <p>Создание сайта от А до Я. Комплексный курс</p>
              </a>
            </div>

            <div class="col-md-4 col-sm-6">
              <a href="../../courses/webdesign/index.html" class="premium-item">
                <span class="premium-img-wrap"><img src="../../public/images/premium/webdesign.jpg" alt="Большой комплексный курс по современному веб-дизайну" class="img-responsive"></span>
                <p>Веб-дизайн с нейросетями для начинающих</p>
              </a>
            </div>

            <div class="col-md-4 col-sm-6">
              <a href="../../courses/freelance/index.html" class="premium-item">
                <span class="premium-img-wrap"><img src="../../public/images/premium/freelance.jpg" alt="Фриланс для начинающих" class="img-responsive"></span>
                <p>Я - фрилансер! Базовый курс для начинающих</p>
              </a>
            </div>

          </div>
        </div>


        <div class="read-more">
          <h4>Другие уроки по теме «CMS/Framework»</h4>
          <ul>
            
            
            
              
              <li><a href="../../blog/cms/576.html">Как создать тему для WordPress. Грамотная посадка верстки на WordPress (Right Way)</a></li>
              
            
              
              <li><a href="../../blog/cms/570.html">Быстрое создание красивых сайтов на WordPress. Layers Style Kit на реальном примере</a></li>
              
            
              
            
              
              <li><a href="../../blog/cms/523.html">Layers. Быстрая разработка сайтов на WordPress #1. Знакомство с Layers WP</a></li>
              
            
              
              <li><a href="../../blog/cms/16.html">Создание лендинга на WordPress с нуля</a></li>
              
            
              
              <li><a href="../../blog/cms/modx-migx-landing-page-section.html">Посадка типовой секции Landing Page на MODx с использованием MIGX (добавляемые поля)</a></li>
              
            
          </ul>
        </div>

      </div>

    </div>

  </div>
</article>


        </div>

        <div class="col-md-4 col-aside">

  <aside class="site-aside">



<div class="box box-search">

<form class="search" action="https://www.google.com/search" target="_blank">
  <div>
    <input type="text" name="q" size="55" placeholder="Поиск по сайту..." required>
    <input type="hidden" name="sitesearch" value="https://webdesign-masteru.github.io">
    <button type="submit">
      <i class="fa fa-search"></i>
    </button>
  </div>
</form>


    </div>

    <nav class="box box-mnu">
      <p class="mnu-header">Разделы сайта:</p>
      <ul class="list-unstyled box-dashed main-menu">

  <li class="d-lg-none">
    <a href="../../courses/index.html"><i class="fa fa-diamond"></i> Курсы</a>
  </li>

  <li>
    <a href="../../blog/html-css/index.html"><i class="fa fa-code"></i> Веб-разработка</a>
  </li>

  <li>
    <a href="../../blog/web-design/index.html"><i class="fa fa-paint-brush"></i> Веб-дизайн</a>
  </li>

  <li>
    <a href="../../blog/tools/index.html"><i class="fa fa-cogs"></i> Инструменты</a>
  </li>

  <li>
    <a href="../../blog/cms/index.html"><i class="fa fa-folder-open-o"></i> CMS/Framework</a>
  </li>

</ul>

    </nav>

    <nav class="box box-mnu services-mnu">
      <p class="mnu-header">Полезные ресурсы:</p>
      <ul class="list-unstyled">

  <li>
    <a href="../../blog/tools/wsl-nodejs-new.html"><i class="fa fa-cogs"></i> Установка WSL и окружения</a>
  </li>

  <li>
    <a href="../../blog/docs/webdev-without-wsl.html"><i class="fa fa-cogs"></i> Настройка окружения без WSL</a>
  </li>

  <li>
    <a href="../../blog/tools/hosting-lesson.html"><i class="fa fa-server"></i> Работа с хостингом от А до Я</a>
  </li>

  <li>
    <a href="../../blog/tools/vscode.html"><i class="fa custom-vscode-3"></i> Настройка VS Code</a>
  </li>

  <li>
    <a href="../../blog/tools/cubic-bezier/index.html"><i class="fa custom-bezier"></i> Cubic-Bezier Generator</a>
  </li>

  <li>
    <a href="../../blog/tools/lazy-load/index.html"><i class="fa fa-image"></i> Lazy Load Placeholder</a>
  </li>

  <li>
    <a href="../../blog/docs/gulp-documentation.html"><i class="fa fa-file-text-o"></i> Документация Gulp</a>
  </li>

</ul>

    </nav>

    <div class="box box-sidebar">
      <div id="vk_groups"></div>
    </div>

  </aside>


        </div>

      </div>

    </div>
  </div>

  <footer class="main-foot">
    <div class="container-fluid">

      <span class="year"></span> © WebDesign Master

    </div>
    <div class="top" title="Наверх"><i class="fa fa-angle-double-up"></i></div>
  </footer>

  <script>(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};m[i].l=1*new Date();for(var j=0;j<document.scripts.length;j++){if(document.scripts[j].src===r){return}}k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})(window,document,"script","https://mc.yandex.ru/metrika/tag.js","ym");ym(100695574,"init",{clickmap:true,trackLinks:true,accurateTrackBounce:true,webvisor:true});</script><noscript><div><img src="https://mc.yandex.ru/watch/100695574" style="position:absolute; left:-9999px;" alt="" /></div></noscript>


</body>
</html>

